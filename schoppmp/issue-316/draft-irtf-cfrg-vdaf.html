<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Verifiable Distributed Aggregation Functions</title>
<meta content="Richard L. Barnes" name="author">
<meta content="David Cook" name="author">
<meta content="Christopher Patton" name="author">
<meta content="Phillipp Schoppmann" name="author">
<meta content="
       This document describes Verifiable Distributed Aggregation Functions (VDAFs), a
family of multi-party protocols for computing aggregate statistics over user
measurements. These protocols are designed to ensure that, as long as at least
one aggregation server executes the protocol honestly, individual measurements
are never seen by any server in the clear. At the same time, VDAFs allow the
servers to detect if a malicious or misconfigured client submitted an
input that would result in an incorrect aggregate result. 
    " name="description">
<meta content="xml2rfc 3.20.0" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-irtf-cfrg-vdaf-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.20.0
    Python 3.11.8
    ConfigArgParse 1.7
    google-i18n-address 3.1.0
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 4.9.3
    platformdirs 4.2.0
    pycountry 22.3.5
    PyYAML 6.0.1
    requests 2.31.0
    setuptools 68.2.2
    six 1.16.0
    wcwidth 0.2.13
-->
<link href="draft-irtf-cfrg-vdaf.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
:is(ol, ul) :is(ol, ul) {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  line-height: 1;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
}
dl.olPercent {
  --indent: 5ch;
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl.dlNewline > dt {
  float: none;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
dl.olPercent > dt {
  min-width: calc(var(--indent) - 2ch);
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:first-child, .break:first-child + *) {
  margin-top: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:last-child) {
  margin-bottom: 0;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0;
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
}
a.pilcrow[href] { color: var(--pilcrow-weak); }
a.pilcrow[href]:hover { text-decoration: none; }
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
}
#identifiers dt {
  width: var(--identifier-width);
  min-width: var(--identifier-width);
  clear: left;
  float: left;
  text-align: right;
  margin-right: 1ch;
}
#identifiers dd {
  margin: 0;
  margin-left: calc(1em + var(--identifier-width)) !important;
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 2px 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 10ch;
  margin-right: 1.5ch;
}
.references dt:target::before {
  content: "⇒";
  width: 15px;
  margin: 0 10px 0 -25px;
}
.references dd {
  margin-left: 12ch !important;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul :is(p, li) {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
  .toplink {
    display: none;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Provide styling for table cell text alignment */
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">VDAF</td>
<td class="right">March 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Barnes, et al.</td>
<td class="center">Expires 8 September 2024</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">CFRG</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-irtf-cfrg-vdaf-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-03-07" class="published">7 March 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2024-09-08">8 September 2024</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">R. L. Barnes</div>
<div class="org">Cisco</div>
</div>
<div class="author">
      <div class="author-name">D. Cook</div>
<div class="org">ISRG</div>
</div>
<div class="author">
      <div class="author-name">C. Patton</div>
<div class="org">Cloudflare</div>
</div>
<div class="author">
      <div class="author-name">P. Schoppmann</div>
<div class="org">Google</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Verifiable Distributed Aggregation Functions</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes Verifiable Distributed Aggregation Functions (VDAFs), a
family of multi-party protocols for computing aggregate statistics over user
measurements. These protocols are designed to ensure that, as long as at least
one aggregation server executes the protocol honestly, individual measurements
are never seen by any server in the clear. At the same time, VDAFs allow the
servers to detect if a malicious or misconfigured client submitted an
input that would result in an incorrect aggregate result.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-discussion-venues">
<a href="#name-discussion-venues" class="section-name selfRef">Discussion Venues</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">Discussion of this document takes place on the
    Crypto Forum Research Group mailing list (cfrg@ietf.org),
    which is archived at <span><a href="https://mailarchive.ietf.org/arch/search/?email_list=cfrg">https://mailarchive.ietf.org/arch/search/?email_list=cfrg</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">Source for this draft and an issue tracker can be found at
    <span><a href="https://github.com/cjpatton/vdaf">https://github.com/cjpatton/vdaf</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 8 September 2024.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-change-log" class="internal xref">Change Log</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions-and-definitions" class="internal xref">Conventions and Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-overview" class="internal xref">Overview</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-definition-of-dafs" class="internal xref">Definition of DAFs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-sharding" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-preparation" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-validity-of-aggregation-par" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-aggregation" class="internal xref">Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="auto internal xref">4.5</a>.  <a href="#name-unsharding" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="auto internal xref">4.6</a>.  <a href="#name-execution-of-a-daf" class="internal xref">Execution of a DAF</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-definition-of-vdafs" class="internal xref">Definition of VDAFs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="auto internal xref">5.1</a>.  <a href="#name-sharding-2" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="auto internal xref">5.2</a>.  <a href="#name-preparation-2" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="auto internal xref">5.3</a>.  <a href="#name-validity-of-aggregation-para" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="auto internal xref">5.4</a>.  <a href="#name-aggregation-2" class="internal xref">Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="auto internal xref">5.5</a>.  <a href="#name-unsharding-2" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.6">
                <p id="section-toc.1-1.5.2.6.1"><a href="#section-5.6" class="auto internal xref">5.6</a>.  <a href="#name-execution-of-a-vdaf" class="internal xref">Execution of a VDAF</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-preliminaries" class="internal xref">Preliminaries</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-finite-fields" class="internal xref">Finite Fields</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="auto internal xref">6.1.1</a>.  <a href="#name-auxiliary-functions" class="internal xref">Auxiliary Functions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="auto internal xref">6.1.2</a>.  <a href="#name-fft-friendly-fields" class="internal xref">FFT-Friendly Fields</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.3">
                    <p id="section-toc.1-1.6.2.1.2.3.1"><a href="#section-6.1.3" class="auto internal xref">6.1.3</a>.  <a href="#name-parameters" class="internal xref">Parameters</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-pseudorandom-generators" class="internal xref">Pseudorandom Generators</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.1">
                    <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="auto internal xref">6.2.1</a>.  <a href="#name-prgsha3" class="internal xref">PrgSha3</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.2">
                    <p id="section-toc.1-1.6.2.2.2.2.1"><a href="#section-6.2.2" class="auto internal xref">6.2.2</a>.  <a href="#name-prgfixedkeyaes128" class="internal xref">PrgFixedKeyAes128</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.3">
                    <p id="section-toc.1-1.6.2.2.2.3.1"><a href="#section-6.2.3" class="auto internal xref">6.2.3</a>.  <a href="#name-the-customization-and-binde" class="internal xref">The Customization and Binder Strings</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-prio3" class="internal xref">Prio3</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-fully-linear-proof-flp-syst" class="internal xref">Fully Linear Proof (FLP) Systems</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1.2.1">
                    <p id="section-toc.1-1.7.2.1.2.1.1"><a href="#section-7.1.1" class="auto internal xref">7.1.1</a>.  <a href="#name-encoding-the-input" class="internal xref">Encoding the Input</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-construction" class="internal xref">Construction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.1">
                    <p id="section-toc.1-1.7.2.2.2.1.1"><a href="#section-7.2.1" class="auto internal xref">7.2.1</a>.  <a href="#name-sharding-3" class="internal xref">Sharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.2">
                    <p id="section-toc.1-1.7.2.2.2.2.1"><a href="#section-7.2.2" class="auto internal xref">7.2.2</a>.  <a href="#name-preparation-3" class="internal xref">Preparation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.3">
                    <p id="section-toc.1-1.7.2.2.2.3.1"><a href="#section-7.2.3" class="auto internal xref">7.2.3</a>.  <a href="#name-validity-of-aggregation-param" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.4">
                    <p id="section-toc.1-1.7.2.2.2.4.1"><a href="#section-7.2.4" class="auto internal xref">7.2.4</a>.  <a href="#name-aggregation-3" class="internal xref">Aggregation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.5">
                    <p id="section-toc.1-1.7.2.2.2.5.1"><a href="#section-7.2.5" class="auto internal xref">7.2.5</a>.  <a href="#name-unsharding-3" class="internal xref">Unsharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.6">
                    <p id="section-toc.1-1.7.2.2.2.6.1"><a href="#section-7.2.6" class="auto internal xref">7.2.6</a>.  <a href="#name-auxiliary-functions-2" class="internal xref">Auxiliary Functions</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="auto internal xref">7.3</a>.  <a href="#name-a-general-purpose-flp" class="internal xref">A General-Purpose FLP</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.1">
                    <p id="section-toc.1-1.7.2.3.2.1.1"><a href="#section-7.3.1" class="auto internal xref">7.3.1</a>.  <a href="#name-overview-2" class="internal xref">Overview</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.2">
                    <p id="section-toc.1-1.7.2.3.2.2.1"><a href="#section-7.3.2" class="auto internal xref">7.3.2</a>.  <a href="#name-validity-circuits" class="internal xref">Validity Circuits</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.3">
                    <p id="section-toc.1-1.7.2.3.2.3.1"><a href="#section-7.3.3" class="auto internal xref">7.3.3</a>.  <a href="#name-construction-2" class="internal xref">Construction</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="auto internal xref">7.4</a>.  <a href="#name-instantiations" class="internal xref">Instantiations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.1">
                    <p id="section-toc.1-1.7.2.4.2.1.1"><a href="#section-7.4.1" class="auto internal xref">7.4.1</a>.  <a href="#name-prio3count" class="internal xref">Prio3Count</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.2">
                    <p id="section-toc.1-1.7.2.4.2.2.1"><a href="#section-7.4.2" class="auto internal xref">7.4.2</a>.  <a href="#name-prio3sum" class="internal xref">Prio3Sum</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.3">
                    <p id="section-toc.1-1.7.2.4.2.3.1"><a href="#section-7.4.3" class="auto internal xref">7.4.3</a>.  <a href="#name-prio3histogram" class="internal xref">Prio3Histogram</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-poplar1" class="internal xref">Poplar1</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="auto internal xref">8.1</a>.  <a href="#name-incremental-distributed-poi" class="internal xref">Incremental Distributed Point Functions (IDPFs)</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="auto internal xref">8.2</a>.  <a href="#name-construction-3" class="internal xref">Construction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.1">
                    <p id="section-toc.1-1.8.2.2.2.1.1"><a href="#section-8.2.1" class="auto internal xref">8.2.1</a>.  <a href="#name-client" class="internal xref">Client</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.2">
                    <p id="section-toc.1-1.8.2.2.2.2.1"><a href="#section-8.2.2" class="auto internal xref">8.2.2</a>.  <a href="#name-preparation-4" class="internal xref">Preparation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.3">
                    <p id="section-toc.1-1.8.2.2.2.3.1"><a href="#section-8.2.3" class="auto internal xref">8.2.3</a>.  <a href="#name-validity-of-aggregation-paramet" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.4">
                    <p id="section-toc.1-1.8.2.2.2.4.1"><a href="#section-8.2.4" class="auto internal xref">8.2.4</a>.  <a href="#name-aggregation-4" class="internal xref">Aggregation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.5">
                    <p id="section-toc.1-1.8.2.2.2.5.1"><a href="#section-8.2.5" class="auto internal xref">8.2.5</a>.  <a href="#name-unsharding-4" class="internal xref">Unsharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.6">
                    <p id="section-toc.1-1.8.2.2.2.6.1"><a href="#section-8.2.6" class="auto internal xref">8.2.6</a>.  <a href="#name-auxiliary-functions-3" class="internal xref">Auxiliary Functions</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="auto internal xref">8.3</a>.  <a href="#name-the-idpf-scheme-of" class="internal xref">The IDPF scheme of BBCGGI21</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.1">
                    <p id="section-toc.1-1.8.2.3.2.1.1"><a href="#section-8.3.1" class="auto internal xref">8.3.1</a>.  <a href="#name-key-generation" class="internal xref">Key Generation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.2">
                    <p id="section-toc.1-1.8.2.3.2.2.1"><a href="#section-8.3.2" class="auto internal xref">8.3.2</a>.  <a href="#name-key-evaluation" class="internal xref">Key Evaluation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.3">
                    <p id="section-toc.1-1.8.2.3.2.3.1"><a href="#section-8.3.3" class="auto internal xref">8.3.3</a>.  <a href="#name-auxiliary-functions-4" class="internal xref">Auxiliary Functions</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.4">
                <p id="section-toc.1-1.8.2.4.1"><a href="#section-8.4" class="auto internal xref">8.4</a>.  <a href="#name-instantiation" class="internal xref">Instantiation</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="auto internal xref">9.1</a>.  <a href="#name-requirements-for-the-verifi" class="internal xref">Requirements for the Verification Key</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="auto internal xref">9.2</a>.  <a href="#name-requirements-for-the-nonce" class="internal xref">Requirements for the Nonce</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.3">
                <p id="section-toc.1-1.9.2.3.1"><a href="#section-9.3" class="auto internal xref">9.3</a>.  <a href="#name-requirements-for-the-aggreg" class="internal xref">Requirements for the Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.4">
                <p id="section-toc.1-1.9.2.4.1"><a href="#section-9.4" class="auto internal xref">9.4</a>.  <a href="#name-additional-privacy-consider" class="internal xref">Additional Privacy Considerations for Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.5">
                <p id="section-toc.1-1.9.2.5.1"><a href="#section-9.5" class="auto internal xref">9.5</a>.  <a href="#name-pseudorandom-generators-and" class="internal xref">Pseudorandom Generators and random oracles</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="auto internal xref">11.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="auto internal xref">11.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-test-vectors" class="internal xref">Test Vectors</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#appendix-B.1" class="auto internal xref"></a><a href="#name-prio3count-2" class="internal xref">Prio3Count</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a href="#appendix-B.2" class="auto internal xref"></a><a href="#name-prio3sum-2" class="internal xref">Prio3Sum</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.3">
                <p id="section-toc.1-1.13.2.3.1"><a href="#appendix-B.3" class="auto internal xref"></a><a href="#name-prio3histogram-2" class="internal xref">Prio3Histogram</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.4">
                <p id="section-toc.1-1.13.2.4.1"><a href="#appendix-B.4" class="auto internal xref"></a><a href="#name-poplar1-2" class="internal xref">Poplar1</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.4.2.1">
                    <p id="section-toc.1-1.13.2.4.2.1.1"><a href="#appendix-B.4.1" class="auto internal xref"></a><a href="#name-sharding-4" class="internal xref">Sharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.4.2.2">
                    <p id="section-toc.1-1.13.2.4.2.2.1"><a href="#appendix-B.4.2" class="auto internal xref"></a><a href="#name-preparation-aggregation-and" class="internal xref">Preparation, Aggregation, and Unsharding</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-C" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The ubiquity of the Internet makes it an ideal platform for measurement of
large-scale phenomena, whether public health trends or the behavior of computer
systems at scale. There is substantial overlap, however, between information
that is valuable to measure and information that users consider private.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">For example, consider an application that provides health information to users.
The operator of an application might want to know which parts of their
application are used most often, as a way to guide future development of the
application.  Specific users' patterns of usage, though, could reveal sensitive
things about them, such as which users are researching a given health condition.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">In many situations, the measurement collector is only interested in aggregate
statistics, e.g., which portions of an application are most used or what
fraction of people have experienced a given disease.  Thus systems that provide
aggregate statistics while protecting individual measurements can deliver the
value of the measurements while protecting users' privacy.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">Most prior approaches to this problem fall under the rubric of "differential
privacy (DP)" <span>[<a href="#Dwo06" class="cite xref">Dwo06</a>]</span>. Roughly speaking, a data aggregation system that is
differentially private ensures that the degree to which any individual
measurement influences the value of the aggregate result can be precisely
controlled. For example, in systems like RAPPOR <span>[<a href="#EPK14" class="cite xref">EPK14</a>]</span>, each user samples
noise from a well-known distribution and adds it to their input before
submitting to the aggregation server. The aggregation server then adds up the
noisy inputs, and because it knows the distribution from whence the noise was
sampled, it can estimate the true sum with reasonable precision.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">Differentially private systems like RAPPOR are easy to deploy and provide a
useful guarantee. On its own, however, DP falls short of the strongest privacy
property one could hope for. Specifically, depending on the "amount" of noise a
client adds to its input, it may be possible for a curious aggregator to make a
reasonable guess of the input's true value. Indeed, the more noise the clients
add, the less reliable will be the server's estimate of the output. Thus systems
employing DP techniques alone must strike a delicate balance between privacy and
utility.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">The ideal goal for a privacy-preserving measurement system is that of secure
multi-party computation (MPC): No participant in the protocol should learn
anything about an individual input beyond what it can deduce from the aggregate.
In this document, we describe Verifiable Distributed Aggregation Functions
(VDAFs) as a general class of protocols that achieve this goal.<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7">VDAF schemes achieve their privacy goal by distributing the computation of the
aggregate among a number of non-colluding aggregation servers. As long as a
subset of the servers executes the protocol honestly, VDAFs guarantee that no
input is ever accessible to any party besides the client that submitted it. At
the same time, VDAFs are "verifiable" in the sense that malformed inputs that
would otherwise garble the output of the computation can be detected and removed
from the set of input measurements.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">In addition to these MPC-style security goals, VDAFs can be composed with
various mechanisms for differential privacy, thereby providing the added
assurance that the aggregate result itself does not leak too much information
about any one measurement.<a href="#section-1-8" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-1-9.1">
          <p id="section-1-9.1.1">TODO(issue #94) Provide guidance for local and central DP and point to it
here.<a href="#section-1-9.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-1-10">The cost of achieving these security properties is the need for multiple servers
to participate in the protocol, and the need to ensure they do not collude to
undermine the VDAF's privacy guarantees.  Recent implementation experience has
shown that practical challenges of coordinating multiple servers can be
overcome.  The Prio system <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span> (essentially a VDAF) has been deployed in
systems supporting hundreds of millions of users: The Mozilla Origin Telemetry
project <span>[<a href="#OriginTelemetry" class="cite xref">OriginTelemetry</a>]</span> and the Exposure Notification Private Analytics
collaboration among the Internet Security Research Group (ISRG), Google, Apple,
and others <span>[<a href="#ENPA" class="cite xref">ENPA</a>]</span>.<a href="#section-1-10" class="pilcrow">¶</a></p>
<p id="section-1-11">The VDAF abstraction laid out in <a href="#vdaf" class="auto internal xref">Section 5</a> represents a class of multi-party
protocols for privacy-preserving measurement proposed in the literature. These
protocols vary in their operational and security considerations, sometimes in
subtle but consequential ways. This document therefore has two important goals:<a href="#section-1-11" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-12">
<li id="section-1-12.1">
          <p id="section-1-12.1.1">Providing higher-level protocols like <span>[<a href="#DAP" class="cite xref">DAP</a>]</span> with a
simple, uniform interface for accessing privacy-preserving measurement
schemes, and documenting relevant operational and security bounds for that
interface:<a href="#section-1-12.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-12.1.2">
<li id="section-1-12.1.2.1">
              <p id="section-1-12.1.2.1.1">General patterns of communications among the various actors involved in
the system (clients, aggregation servers, and the collector of the
aggregate result);<a href="#section-1-12.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-12.1.2.2">
              <p id="section-1-12.1.2.2.1">Capabilities of a malicious coalition of servers attempting to divulge
information about client measurements; and<a href="#section-1-12.1.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-12.1.2.3">
              <p id="section-1-12.1.2.3.1">Conditions that are necessary to ensure that malicious clients cannot
corrupt the computation.<a href="#section-1-12.1.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</li>
        <li id="section-1-12.2">
          <p id="section-1-12.2.1">Providing cryptographers with design criteria that provide a clear
deployment roadmap for new constructions.<a href="#section-1-12.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-1-13">This document also specifies two concrete VDAF schemes, each based on a protocol
from the literature.<a href="#section-1-13" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1-14.1">
          <p id="section-1-14.1.1">The aforementioned Prio system <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span> allows for the privacy-preserving
computation of a variety aggregate statistics. The basic idea underlying Prio
is fairly simple:<a href="#section-1-14.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-14.1.2">
<li id="section-1-14.1.2.1">
              <p id="section-1-14.1.2.1.1">Each client shards its measurement into a sequence of additive shares and
distributes the shares among the aggregation servers.<a href="#section-1-14.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-14.1.2.2">
              <p id="section-1-14.1.2.2.1">Next, each server adds up its shares locally, resulting in an additive
share of the aggregate.<a href="#section-1-14.1.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-14.1.2.3">
              <p id="section-1-14.1.2.3.1">Finally, the aggregation servers send their aggregate shares to the data
collector, who combines them to obtain the aggregate result.<a href="#section-1-14.1.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-1-14.1.3">
The difficult part of this system is ensuring that the servers hold shares of
a valid input, e.g., the input is an integer in a specific range. Thus Prio
specifies a multi-party protocol for accomplishing this task.<a href="#section-1-14.1.3" class="pilcrow">¶</a></p>
<p id="section-1-14.1.4">
In <a href="#prio3" class="auto internal xref">Section 7</a> we describe Prio3, a VDAF that follows the same overall framework
as the original Prio protocol, but incorporates techniques introduced in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> that result in significant performance gains.<a href="#section-1-14.1.4" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-14.2">
          <p id="section-1-14.2.1">More recently, Boneh et al. <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> described a protocol called Poplar
for solving the <code>t</code>-heavy-hitters problem in a privacy-preserving manner. Here
each client holds a bit-string of length <code>n</code>, and the goal of the aggregation
servers is to compute the set of inputs that occur at least <code>t</code> times. The
core primitive used in their protocol is a specialized Distributed Point
Function (DPF) <span>[<a href="#GI14" class="cite xref">GI14</a>]</span> that allows the servers to "query" their DPF shares on
any bit-string of length shorter than or equal to <code>n</code>. As a result of this
query, each of the servers has an additive share of a bit indicating whether
the string is a prefix of the client's input. The protocol also specifies a
multi-party computation for verifying that at most one string among a set of
candidates is a prefix of the client's input.<a href="#section-1-14.2.1" class="pilcrow">¶</a></p>
<p id="section-1-14.2.2">
In <a href="#poplar1" class="auto internal xref">Section 8</a> we describe a VDAF called Poplar1 that implements this
functionality.<a href="#section-1-14.2.2" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-1-15">Finally, perhaps the most complex aspect of schemes like Prio3 and Poplar1 is
the process by which the client-generated measurements are prepared for
aggregation. Because these constructions are based on secret sharing, the
servers will be required to exchange some amount of information in order to
verify the measurement is valid and can be aggregated. Depending on the
construction, this process may require multiple round trips over the network.<a href="#section-1-15" class="pilcrow">¶</a></p>
<p id="section-1-16">There are applications in which this verification step may not be necessary,
e.g., when the client's software is run a trusted execution environment. To
support these applications, this document also defines Distributed Aggregation
Functions (DAFs) as a simpler class of protocols that aim to provide the same
privacy guarantee as VDAFs but fall short of being verifiable.<a href="#section-1-16" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-1-17.1">
          <p id="section-1-17.1.1">OPEN ISSUE Decide if we should give one or two example DAFs. There are natural
variants of Prio3 and Poplar1 that might be worth describing.<a href="#section-1-17.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-1-18">The remainder of this document is organized as follows: <a href="#overview" class="auto internal xref">Section 3</a> gives a
brief overview of DAFs and VDAFs; <a href="#daf" class="auto internal xref">Section 4</a> defines the syntax for DAFs; <a href="#vdaf" class="auto internal xref">Section 5</a>
defines the syntax for VDAFs; <a href="#prelim" class="auto internal xref">Section 6</a> defines various functionalities that
are common to our constructions; <a href="#prio3" class="auto internal xref">Section 7</a> describes the Prio3 construction;
<a href="#poplar1" class="auto internal xref">Section 8</a> describes the Poplar1 construction; and <a href="#security" class="auto internal xref">Section 9</a> enumerates the
security considerations for VDAFs.<a href="#section-1-18" class="pilcrow">¶</a></p>
<div id="change-log">
<section id="section-1.1">
        <h3 id="name-change-log">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-change-log" class="section-name selfRef">Change Log</a>
        </h3>
<p id="section-1.1-1">(*) Indicates a change that breaks wire compatibility with the previous draft.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">05:<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-3.1">
            <p id="section-1.1-3.1.1">IdpfPoplar: Replace PrgSha3 with PrgFixedKeyAes128, a fixed-key mode for
AES-128 based on a construction from <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>. This change is intended to
improve performance of IDPF evaluation. Note that the new PRG is not suitable
for all applications. (*)<a href="#section-1.1-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-3.2">
            <p id="section-1.1-3.2.1">Idpf: Add a binder string to the key-generation and evaluation algorithms.
This is used to plumb the nonce generated by the Client to the PRG.<a href="#section-1.1-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-3.3">
            <p id="section-1.1-3.3.1">Plumb random coins through the interface of randomized algorithms.
Specifically, add a random input to (V)DAF sharding algorithm and IDPF
key-generation algorithm and require implementations to specify the length of
the random input. Accordingly, update Prio3, Poplar1, and IdpfPoplar to match
the new interface. This change is intended to improve coverage of test
vectors.<a href="#section-1.1-3.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-3.4">
            <p id="section-1.1-3.4.1">Use little-endian byte-order for field element encoding. (*)<a href="#section-1.1-3.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-3.5">
            <p id="section-1.1-3.5.1">Poplar1: Move the last step of sketch evaluation from <code>prep_next()</code> to
<code>prep_shares_to_prep()</code>.<a href="#section-1.1-3.5.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-4">04:<a href="#section-1.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-5.1">
            <p id="section-1.1-5.1.1">Align security considerations with the security analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>.<a href="#section-1.1-5.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.2">
            <p id="section-1.1-5.2.1">Vdaf: Pass the nonce to the sharding algorithm.<a href="#section-1.1-5.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.3">
            <p id="section-1.1-5.3.1">Vdaf: Rather than allow the application to choose the nonce length, have each
implementation of the Vdaf interface specify the expected nonce length. (*)<a href="#section-1.1-5.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.4">
            <p id="section-1.1-5.4.1">Prg: Split "info string" into two components: the "customization string",
intended for domain separation; and the "binder string", used to bind the
output to ephemeral values, like the nonce, associated with execution of a
(V)DAF.<a href="#section-1.1-5.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.5">
            <p id="section-1.1-5.5.1">Replace PrgAes128 with PrgSha3, an implementation of the Prg interface based
on SHA-3, and use the new scheme as the default. Accordingly, replace
Prio3Aes128Count with Prio3Count, Poplar1Aes128 with Poplar1, and so on. SHA-3
is a safer choice for instantiating a random oracle, which is used in the
analysis of Prio3 of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. (*)<a href="#section-1.1-5.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.6">
            <p id="section-1.1-5.6.1">Prio3, Poplar1: Ensure each invocation of the Prg uses a distinct
customization string, as suggested by <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. This is intended to make
domain separation clearer, thereby simplifying security analysis. (*)<a href="#section-1.1-5.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.7">
            <p id="section-1.1-5.7.1">Prio3: Replace "joint randomness hints" sent in each input share with "joint
randomness parts" sent in the public share. This reduces communication
overhead when the number of shares exceeds two. (*)<a href="#section-1.1-5.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.8">
            <p id="section-1.1-5.8.1">Prio3: Bind nonce to joint randomness parts. This is intended to address
birthday attacks on robustness pointed out by <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. (*)<a href="#section-1.1-5.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.9">
            <p id="section-1.1-5.9.1">Poplar1: Use different Prg invocations for producing the correlated randomness
for inner and leaf nodes of the IDPF tree. This is intended to simplify
implementations. (*)<a href="#section-1.1-5.9.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.10">
            <p id="section-1.1-5.10.1">Poplar1: Don't bind the candidate prefixes to the verifier randomness. This is
intended to improve performance, while not impacting security. According to
the analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, it is necessary to restrict Poplar1 usage such
that no report is aggregated more than once at a given level of the IDPF tree;
otherwise, attacks on privacy may be possible. In light of this restriction,
there is no added benefit of binding to the prefixes themselves. (*)<a href="#section-1.1-5.10.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.11">
            <p id="section-1.1-5.11.1">Poplar1: During preparation, assert that all candidate prefixes are unique
and appear in order. Uniqueness is required to avoid erroneously rejecting a
valid report; the ordering constraint ensures the uniqueness check can be
performed efficiently. (*)<a href="#section-1.1-5.11.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.12">
            <p id="section-1.1-5.12.1">Poplar1: Increase the maximum candidate prefix count in the encoding of the
aggregation parameter. (*)<a href="#section-1.1-5.12.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.13">
            <p id="section-1.1-5.13.1">Poplar1: Bind the nonce to the correlated randomness derivation. This is
intended to provide defense-in-depth by ensuring the Aggregators reject the
report if the nonce does not match what the Client used for sharding. (*)<a href="#section-1.1-5.13.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.14">
            <p id="section-1.1-5.14.1">Poplar1: Clarify that the aggregation parameter encoding is <span class="bcp14">OPTIONAL</span>.
Accordingly, update implementation considerations around cross-aggregation
state.<a href="#section-1.1-5.14.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.15">
            <p id="section-1.1-5.15.1">IdpfPoplar: Add implementation considerations around branching on the values
of control bits.<a href="#section-1.1-5.15.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-5.16">
            <p id="section-1.1-5.16.1">IdpfPoplar: When decoding the the control bits in the public share, assert
that the trailing bits of the final byte are all zero. (*)<a href="#section-1.1-5.16.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-6">03:<a href="#section-1.1-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-7.1">
            <p id="section-1.1-7.1.1">Define codepoints for (V)DAFs and use them for domain separation in Prio3 and
Poplar1. (*)<a href="#section-1.1-7.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-7.2">
            <p id="section-1.1-7.2.1">Prio3: Align joint randomness computation with revised paper <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>.
This change mitigates an attack on robustness. (*)<a href="#section-1.1-7.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-7.3">
            <p id="section-1.1-7.3.1">Prio3: Remove an intermediate PRG evaluation from query randomness generation.
(*)<a href="#section-1.1-7.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-7.4">
            <p id="section-1.1-7.4.1">Add additional guidance for choosing FFT-friendly fields.<a href="#section-1.1-7.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-8">02:<a href="#section-1.1-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-9.1">
            <p id="section-1.1-9.1.1">Complete the initial specification of Poplar1.<a href="#section-1.1-9.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.2">
            <p id="section-1.1-9.2.1">Extend (V)DAF syntax to include a "public share" output by the Client and
distributed to all of the Aggregators. This is to accommodate "extractable"
IDPFs as required for Poplar1. (See <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Section 4.3 for details.)<a href="#section-1.1-9.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.3">
            <p id="section-1.1-9.3.1">Extend (V)DAF syntax to allow the unsharding step to take into account the
number of measurements aggregated.<a href="#section-1.1-9.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.4">
            <p id="section-1.1-9.4.1">Extend FLP syntax by adding a method for decoding the aggregate result from a
vector of field elements. The new method takes into account the number of
measurements.<a href="#section-1.1-9.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.5">
            <p id="section-1.1-9.5.1">Prio3: Align aggregate result computation with updated FLP syntax.<a href="#section-1.1-9.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.6">
            <p id="section-1.1-9.6.1">Prg: Add a method for statefully generating a vector of field elements.<a href="#section-1.1-9.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.7">
            <p id="section-1.1-9.7.1">Field: Require that field elements are fully reduced before decoding. (*)<a href="#section-1.1-9.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-9.8">
            <p id="section-1.1-9.8.1">Define new field Field255.<a href="#section-1.1-9.8.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-10">01:<a href="#section-1.1-10" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-11.1">
            <p id="section-1.1-11.1.1">Require that VDAFs specify serialization of aggregate shares.<a href="#section-1.1-11.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-11.2">
            <p id="section-1.1-11.2.1">Define Distributed Aggregation Functions (DAFs).<a href="#section-1.1-11.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-11.3">
            <p id="section-1.1-11.3.1">Prio3: Move proof verifier check from <code>prep_next()</code> to
<code>prep_shares_to_prep()</code>. (*)<a href="#section-1.1-11.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-11.4">
            <p id="section-1.1-11.4.1">Remove public parameter and replace verification parameter with a
"verification key" and "Aggregator ID".<a href="#section-1.1-11.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="conventions-and-definitions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
"<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Algorithms in this document are written in Python 3. Type hints are used to
define input and output types. A fatal error in a program (e.g., failure to
parse one of the function parameters) is usually handled by raising an
exception.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">A variable with type <code>Bytes</code> is a byte string. This document defines several
byte-string constants. When comprised of printable ASCII characters, they are
written as Python 3 byte-string literals (e.g., <code>b'some constant string'</code>).<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">A global constant <code>VERSION</code> of type <code>Unsigned</code> is defined, which algorithms are
free to use as desired. Its value <span class="bcp14">SHALL</span> be <code>5</code>.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">This document describes algorithms for multi-party computations in which the
parties typically communicate over a network. Wherever a quantity is defined
that must be be transmitted from one party to another, this document prescribes
a particular encoding of that quantity as a byte string.<a href="#section-2-5" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-2-6.1">
          <p id="section-2-6.1.1">OPEN ISSUE It might be better to not be prescriptive about how quantities are
encoded on the wire. See issue #58.<a href="#section-2-6.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-7">Some common functionalities:<a href="#section-2-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-8.1">
          <p id="section-2-8.1.1"><code>zeros(len: Unsigned) -&gt; Bytes</code> returns an array of zero bytes. The length of
<code>output</code> <span class="bcp14">MUST</span> be <code>len</code>.<a href="#section-2-8.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.2">
          <p id="section-2-8.2.1"><code>gen_rand(len: Unsigned) -&gt; Bytes</code> returns an array of random bytes. The
length of <code>output</code> <span class="bcp14">MUST</span> be <code>len</code>.<a href="#section-2-8.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.3">
          <p id="section-2-8.3.1"><code>byte(int: Unsigned) -&gt; Bytes</code> returns the representation of <code>int</code> as a byte
string. The value of <code>int</code> <span class="bcp14">MUST</span> be in <code>[0,256)</code>.<a href="#section-2-8.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.4">
          <p id="section-2-8.4.1"><code>concat(parts: Vec[Bytes]) -&gt; Bytes</code> returns the concatenation of the input
byte strings, i.e., <code>parts[0] || ... || parts[len(parts)-1]</code>.<a href="#section-2-8.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.5">
          <p id="section-2-8.5.1"><code>xor(left: Bytes, right: Bytes) -&gt; Bytes</code> returns the bitwise XOR of <code>left</code>
and <code>right</code>. An exception is raised if the inputs are not the same length.<a href="#section-2-8.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.6">
          <p id="section-2-8.6.1"><code>to_be_bytes(val: Unsigned, length: Unsigned) -&gt; Bytes</code> converts <code>val</code> to
big-endian bytes; its value <span class="bcp14">MUST</span> be in range <code>[0, 2^(8*length))</code>. Function
<code>from_be_bytes(encoded: Bytes) -&gt; Unsigned</code> computes the inverse.<a href="#section-2-8.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.7">
          <p id="section-2-8.7.1"><code>to_le_bytes(val: Unsigned, length: Unsigned) -&gt; Bytes</code> converts <code>val</code> to
little-endian bytes; its value <span class="bcp14">MUST</span> be in range <code>[0, 2^(8*length))</code>. Function
<code>from_le_bytes(encoded: Bytes) -&gt; Unsigned</code> computes the inverse.<a href="#section-2-8.7.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.8">
          <p id="section-2-8.8.1"><code>next_power_of_2(n: Unsigned) -&gt; Unsigned</code> returns the smallest integer
greater than or equal to <code>n</code> that is also a power of two.<a href="#section-2-8.8.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="overview">
<section id="section-3">
      <h2 id="name-overview">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-overview" class="section-name selfRef">Overview</a>
      </h2>
<span id="name-overall-data-flow-of-a-vdaf"></span><div id="overall-flow">
<figure id="figure-1">
        <div class="alignLeft art-text artwork" id="section-3-1.1">
<pre>
                 +--------------+
           +----&gt;| Aggregator 0 |----+
           |     +--------------+    |
           |             ^           |
           |             |           |
           |             V           |
           |     +--------------+    |
           | +--&gt;| Aggregator 1 |--+ |
           | |   +--------------+  | |
+--------+-+ |           ^         | +-&gt;+-----------+
| Client |---+           |         +---&gt;| Collector |--&gt; Aggregate
+--------+-+                         +-&gt;+-----------+
           |            ...          |
           |                         |
           |             |           |
           |             V           |
           |    +----------------+   |
           +---&gt;| Aggregator N-1 |---+
                +----------------+

      Input shares           Aggregate shares
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-overall-data-flow-of-a-vdaf" class="selfRef">Overall data flow of a (V)DAF</a>
        </figcaption></figure>
</div>
<p id="section-3-2">In a DAF- or VDAF-based private measurement system, we distinguish three types
of actors: Clients, Aggregators, and Collectors.  The overall flow of the
measurement process is as follows:<a href="#section-3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.1">
          <p id="section-3-3.1.1">To submit an individual measurement, the Client shards the measurement into
"input shares" and sends one input share to each Aggregator. We sometimes
refer to this sequence of input shares collectively as the Client's "report".<a href="#section-3-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.2">
          <p id="section-3-3.2.1">The Aggregators convert their input shares into "output shares".<a href="#section-3-3.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.2.2.1">
              <p id="section-3-3.2.2.1.1">Output shares are in one-to-one correspondence with the input shares.<a href="#section-3-3.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3-3.2.2.2">
              <p id="section-3-3.2.2.2.1">Just as each Aggregator receives one input share of each input, at the end
of this process, each aggregator holds one output share.<a href="#section-3-3.2.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3-3.2.2.3">
              <p id="section-3-3.2.2.3.1">In VDAFs, Aggregators will need to exchange information among themselves
as part of the validation process.<a href="#section-3-3.2.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-3-3.3">
          <p id="section-3-3.3.1">Each Aggregator combines the output shares across inputs in the batch to
compute the "aggregate share" for that batch, i.e., its share of the desired
aggregate result.<a href="#section-3-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.4">
          <p id="section-3-3.4.1">The Aggregators submit their aggregate shares to the Collector, who combines
them to obtain the aggregate result over the batch.<a href="#section-3-3.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-3-4">Aggregators are a new class of actor relative to traditional measurement systems
where clients submit measurements to a single server.  They are critical for
both the privacy properties of the system and, in the case of VDAFs, the
correctness of the measurements obtained.  The privacy properties of the system
are assured by non-collusion among Aggregators, and Aggregators are the entities
that perform validation of Client measurements.  Thus clients trust Aggregators
not to collude (typically it is required that at least one Aggregator is
honest), and Collectors trust Aggregators to correctly run the protocol.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">Within the bounds of the non-collusion requirements of a given (V)DAF instance,
it is possible for the same entity to play more than one role.  For example, the
Collector could also act as an Aggregator, effectively using the other
Aggregator(s) to augment a basic client-server protocol.<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">In this document, we describe the computations performed by the actors in this
system. It is up to the higher-level protocol making use of the (V)DAF to
arrange for the required information to be delivered to the proper actors in the
proper sequence. In general, we assume that all communications are confidential
and mutually authenticated, with the exception that Clients submitting
measurements may be anonymous.<a href="#section-3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="daf">
<section id="section-4">
      <h2 id="name-definition-of-dafs">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-definition-of-dafs" class="section-name selfRef">Definition of DAFs</a>
      </h2>
<p id="section-4-1">By way of a gentle introduction to VDAFs, this section describes a simpler class
of schemes called Distributed Aggregation Functions (DAFs). Unlike VDAFs, DAFs
do not provide verifiability of the computation. Clients must therefore be
trusted to compute their input shares correctly. Because of this fact, the use
of a DAF is <span class="bcp14">NOT RECOMMENDED</span> for most applications. See <a href="#security" class="auto internal xref">Section 9</a> for
additional discussion.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">A DAF scheme is used to compute a particular "aggregation function" over a set
of measurements generated by Clients. Depending on the aggregation function, the
Collector might select an "aggregation parameter" and disseminates it to the
Aggregators. The semantics of this parameter is specific to the aggregation
function, but in general it is used to represent the set of "queries" that can
be made on the measurement set. For example, the aggregation parameter is used
to represent the candidate prefixes in Poplar1 <a href="#poplar1" class="auto internal xref">Section 8</a>.<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">Execution of a DAF has four distinct stages:<a href="#section-4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-4.1">
          <p id="section-4-4.1.1">Sharding - Each Client generates input shares from its measurement and
distributes them among the Aggregators.<a href="#section-4-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.2">
          <p id="section-4-4.2.1">Preparation - Each Aggregator converts each input share into an output share
compatible with the aggregation function. This computation involves the
aggregation parameter. In general, each aggregation parameter may result in a
different an output share.<a href="#section-4-4.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.3">
          <p id="section-4-4.3.1">Aggregation - Each Aggregator combines a sequence of output shares into its
aggregate share and sends the aggregate share to the Collector.<a href="#section-4-4.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.4">
          <p id="section-4-4.4.1">Unsharding - The Collector combines the aggregate shares into the aggregate
result.<a href="#section-4-4.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-4-5">Sharding and Preparation are done once per measurement. Aggregation and
Unsharding are done over a batch of measurements (more precisely, over the
recovered output shares).<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">A concrete DAF specifies an algorithm for the computation needed in each of
these stages. The interface of each algorithm is defined in the remainder of
this section. In addition, a concrete DAF defines the associated constants and
types enumerated in the following table.<a href="#section-4-6" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined"></span><div id="daf-param">
<table class="center" id="table-1">
        <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-constants-and-types-defined" class="selfRef">Constants and types defined by each concrete DAF.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ID</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Algorithm identifier for this DAF.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>SHARES</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of input shares into which each measurement is sharded</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the random byte string passed to sharding algorithm</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Measurement</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each measurement</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggParam</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of aggregation parameter</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OutShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each output share</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggResult</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-4-8">These types define some of the inputs and outputs of DAF methods at various
stages of the computation. Observe that only the measurements, output shares,
the aggregate result, and the aggregation parameter have an explicit type. All
other values --- in particular, the input shares and the aggregate shares ---
have type <code>Bytes</code> and are treated as opaque byte strings. This is because these
values must be transmitted between parties over a network.<a href="#section-4-8" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4-9.1">
          <p id="section-4-9.1.1">OPEN ISSUE It might be cleaner to define a type for each value, then have that
type implement an encoding where necessary. This way each method parameter has
a meaningful type hint. See issue#58.<a href="#section-4-9.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-4-10">Each DAF is identified by a unique, 32-bit integer <code>ID</code>. Identifiers for each
(V)DAF specified in this document are defined in <a href="#codepoints" class="auto internal xref">Table 16</a>.<a href="#section-4-10" class="pilcrow">¶</a></p>
<div id="sec-daf-shard">
<section id="section-4.1">
        <h3 id="name-sharding">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-sharding" class="section-name selfRef">Sharding</a>
        </h3>
<p id="section-4.1-1">In order to protect the privacy of its measurements, a DAF Client shards its
measurements into a sequence of input shares. The <code>measurement_to_input_shares</code>
method is used for this purpose.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-2.1">
            <p id="section-4.1-2.1.1"><code>Daf.measurement_to_input_shares(input: Measurement, rand:
Bytes[Daf.RAND_SIZE]) -&gt; (Bytes, Vec[Bytes])</code> is the randomized sharding
algorithm run by each Client. (The input <code>rand</code> consists of the random coins
consumed by the algorithm.) It consumes the measurement and produces a "public
share", distributed to each of the Aggregators, and a corresponding sequence
of input shares, one for each Aggregator. The length of the output vector <span class="bcp14">MUST</span>
be <code>SHARES</code>.<a href="#section-4.1-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<span id="name-the-client-divides-its-meas"></span><div id="shard-flow">
<figure id="figure-2">
          <div class="alignLeft art-text artwork" id="section-4.1-3.1">
<pre>
    Client
    ======

    measurement
      |
      V
    +----------------------------------------------+
    | measurement_to_input_shares                  |
    +----------------------------------------------+
      |              |              ...  |
      V              V                   V
     input_share_0  input_share_1       input_share_[SHARES-1]
      |              |              ...  |
      V              V                   V
    Aggregator 0   Aggregator 1        Aggregator SHARES-1
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-the-client-divides-its-meas" class="selfRef">The Client divides its measurement into input shares and distributes them to the Aggregators.</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="sec-daf-prepare">
<section id="section-4.2">
        <h3 id="name-preparation">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-preparation" class="section-name selfRef">Preparation</a>
        </h3>
<p id="section-4.2-1">Once an Aggregator has received the public share and one of the input shares,
the next step is to prepare the input share for aggregation. This is
accomplished using the following algorithm:<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2-2.1">
            <p id="section-4.2-2.1.1"><code>Daf.prep(agg_id: Unsigned, agg_param: AggParam, public_share: Bytes,
input_share: Bytes) -&gt; OutShare</code> is the deterministic preparation algorithm.
It takes as input the public share and one of the input shares generated by a
Client, the Aggregator's unique identifier, and the aggregation parameter
selected by the Collector and returns an output share.<a href="#section-4.2-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.2-3">The protocol in which the DAF is used <span class="bcp14">MUST</span> ensure that the Aggregator's
identifier is equal to the integer in range <code>[0, SHARES)</code> that matches the index
of <code>input_share</code> in the sequence of input shares output by the Client.<a href="#section-4.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-daf-validity-scopes">
<section id="section-4.3">
        <h3 id="name-validity-of-aggregation-par">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-validity-of-aggregation-par" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-4.3-1">Concrete DAFs implementations <span class="bcp14">MAY</span> impose certain restrictions for input shares
and aggregation parameters. Protocols using a DAF <span class="bcp14">MUST</span> ensure that for each
input share and aggregation parameter <code>agg_param</code>, <code>Daf.prep</code> is only called if
<code>Daf.is_valid(agg_param, previous_agg_params)</code> returns True, where
<code>previous_agg_params</code> contains all aggregation parameters that have previously
been used with the same input share.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">DAFs <span class="bcp14">MUST</span> implement the following function:<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3-3.1">
            <p id="section-4.3-3.1.1"><code>Daf.is_valid(agg_param: AggParam, previous_agg_params: Vec[AggParam]) -&gt;
Bool</code>: Checks if the <code>agg_param</code> is compatible with all elements of
<code>previous_agg_params</code>.<a href="#section-4.3-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec-daf-aggregate">
<section id="section-4.4">
        <h3 id="name-aggregation">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-aggregation" class="section-name selfRef">Aggregation</a>
        </h3>
<p id="section-4.4-1">Once an Aggregator holds output shares for a batch of measurements (where
batches are defined by the application), it combines them into a share of the
desired aggregate result:<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-2.1">
            <p id="section-4.4-2.1.1"><code>Daf.out_shares_to_agg_share(agg_param: AggParam, out_shares: Vec[OutShare])
-&gt; agg_share: Bytes</code> is the deterministic aggregation algorithm. It is run by
each Aggregator a set of recovered output shares.<a href="#section-4.4-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<span id="name-aggregation-of-output-share"></span><div id="aggregate-flow">
<figure id="figure-3">
          <div class="alignLeft art-text artwork" id="section-4.4-3.1">
<pre>
    Aggregator 0    Aggregator 1        Aggregator SHARES-1
    ============    ============        ===================

    out_share_0_0   out_share_1_0       out_share_[SHARES-1]_0
    out_share_0_1   out_share_1_1       out_share_[SHARES-1]_1
    out_share_0_2   out_share_1_2       out_share_[SHARES-1]_2
         ...             ...                     ...
    out_share_0_B   out_share_1_B       out_share_[SHARES-1]_B
      |               |                   |
      V               V                   V
    +-----------+   +-----------+       +-----------+
    | out2agg   |   | out2agg   |   ... | out2agg   |
    +-----------+   +-----------+       +-----------+
      |               |                   |
      V               V                   V
    agg_share_0     agg_share_1         agg_share_[SHARES-1]
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-aggregation-of-output-share" class="selfRef">Aggregation of output shares. `B` indicates the number of measurements in the batch.</a>
          </figcaption></figure>
</div>
<p id="section-4.4-4">For simplicity, we have written this algorithm in a "one-shot" form, where all
output shares for a batch are provided at the same time. Many DAFs may also
support a "streaming" form, where shares are processed one at a time.<a href="#section-4.4-4" class="pilcrow">¶</a></p>
<p id="section-4.4-5">Implementation note: For most natural DAFs (and VDAFs) it is not necessary for
an Aggregator to store all output shares individually before aggregating.
Typically it is possible to merge output shares into aggregate shares as they
arrive, merge these into other aggregate shares, and so on. In particular, this
is the case when the output shares are vectors over some finite field and
aggregating them involves merely adding up the vectors element-wise. Such is the
case for Prio3 <a href="#prio3" class="auto internal xref">Section 7</a> and Poplar1 <a href="#poplar1" class="auto internal xref">Section 8</a>.<a href="#section-4.4-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-daf-unshard">
<section id="section-4.5">
        <h3 id="name-unsharding">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-unsharding" class="section-name selfRef">Unsharding</a>
        </h3>
<p id="section-4.5-1">After the Aggregators have aggregated a sufficient number of output shares, each
sends its aggregate share to the Collector, who runs the following algorithm to
recover the following output:<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5-2.1">
            <p id="section-4.5-2.1.1"><code>Daf.agg_shares_to_result(agg_param: AggParam,
agg_shares: Vec[Bytes], num_measurements: Unsigned) -&gt; AggResult</code> is
run by the Collector in order to compute the aggregate result from
the Aggregators' shares. The length of <code>agg_shares</code> <span class="bcp14">MUST</span> be <code>SHARES</code>.
<code>num_measurements</code> is the number of measurements that contributed to
each of the aggregate shares. This algorithm is deterministic.<a href="#section-4.5-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<span id="name-computation-of-the-final-ag"></span><div id="unshard-flow">
<figure id="figure-4">
          <div class="alignLeft art-text artwork" id="section-4.5-3.1">
<pre>
    Aggregator 0    Aggregator 1        Aggregator SHARES-1
    ============    ============        ===================

    agg_share_0     agg_share_1         agg_share_[SHARES-1]
      |               |                   |
      V               V                   V
    +-----------------------------------------------+
    | agg_shares_to_result                          |
    +-----------------------------------------------+
      |
      V
    agg_result

    Collector
    =========
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-computation-of-the-final-ag" class="selfRef">Computation of the final aggregate result from aggregate shares.</a>
          </figcaption></figure>
</div>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.5-4.1">
            <p id="section-4.5-4.1.1">QUESTION Maybe the aggregation algorithms should be randomized in order to
allow the Aggregators (or the Collector) to add noise for differential
privacy. (See the security considerations of <span>[<a href="#DAP" class="cite xref">DAP</a>]</span>.)
Or is this out-of-scope of this document? See
https://github.com/ietf-wg-ppm/ppm-specification/issues/19.<a href="#section-4.5-4.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="daf-execution">
<section id="section-4.6">
        <h3 id="name-execution-of-a-daf">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-execution-of-a-daf" class="section-name selfRef">Execution of a DAF</a>
        </h3>
<p id="section-4.6-1">Securely executing a DAF involves emulating the following procedure.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<span id="name-execution-of-a-daf-2"></span><div id="run-daf">
<figure id="figure-5">
          <div class="alignLeft art-text artwork" id="section-4.6-2.1">
<pre>
def run_daf(Daf,
            agg_param: Daf.AggParam,
            measurements: Vec[Daf.Measurement]):
    out_shares = [ [] for j in range(Daf.SHARES) ]
    for measurement in measurements:
        # Each Client shards its measurement into input shares and
        # distributes them among the Aggregators.
        rand = gen_rand(Daf.RAND_SIZE)
        (public_share, input_shares) = \
            Daf.measurement_to_input_shares(measurement, rand)

        # Each Aggregator prepares its input share for aggregation.
        for j in range(Daf.SHARES):
            out_shares[j].append(
                Daf.prep(j, agg_param, public_share, input_shares[j]))

    # Each Aggregator aggregates its output shares into an aggregate
    # share and sends it to the Collector.
    agg_shares = []
    for j in range(Daf.SHARES):
        agg_share_j = Daf.out_shares_to_agg_share(agg_param,
                                                  out_shares[j])
        agg_shares.append(agg_share_j)

    # Collector unshards the aggregate result.
    num_measurements = len(measurements)
    agg_result = Daf.agg_shares_to_result(agg_param, agg_shares,
                                          num_measurements)
    return agg_result
</pre>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-execution-of-a-daf-2" class="selfRef">Execution of a DAF.</a>
          </figcaption></figure>
</div>
<p id="section-4.6-3">The inputs to this procedure are the same as the aggregation function computed by
the DAF: An aggregation parameter and a sequence of measurements. The procedure
prescribes how a DAF is executed in a "benign" environment in which there is no
adversary and the messages are passed among the protocol participants over
secure point-to-point channels. In reality, these channels need to be
instantiated by some "wrapper protocol", such as <span>[<a href="#DAP" class="cite xref">DAP</a>]</span>,
that realizes these channels using suitable cryptographic mechanisms. Moreover,
some fraction of the Aggregators (or Clients) may be malicious and diverge from
their prescribed behaviors. <a href="#security" class="auto internal xref">Section 9</a> describes the execution of the DAF in
various adversarial environments and what properties the wrapper protocol needs
to provide in each.<a href="#section-4.6-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="vdaf">
<section id="section-5">
      <h2 id="name-definition-of-vdafs">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-definition-of-vdafs" class="section-name selfRef">Definition of VDAFs</a>
      </h2>
<p id="section-5-1">Like DAFs described in the previous section, a VDAF scheme is used to compute a
particular aggregation function over a set of Client-generated measurements.
Evaluation of a VDAF involves the same four stages as for DAFs: Sharding,
Preparation, Aggregation, and Unsharding. However, the Preparation stage will
require interaction among the Aggregators in order to facilitate verifiability
of the computation's correctness. Accommodating this interaction will require
syntactic changes.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">Overall execution of a VDAF comprises the following stages:<a href="#section-5-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-3.1">
          <p id="section-5-3.1.1">Sharding - Computing input shares from an individual measurement<a href="#section-5-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-3.2">
          <p id="section-5-3.2.1">Preparation - Conversion and verification of input shares to output shares
compatible with the aggregation function being computed<a href="#section-5-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-3.3">
          <p id="section-5-3.3.1">Aggregation - Combining a sequence of output shares into an aggregate share<a href="#section-5-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-3.4">
          <p id="section-5-3.4.1">Unsharding - Combining a sequence of aggregate shares into an aggregate
result<a href="#section-5-3.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-5-4">In contrast to DAFs, the Preparation stage for VDAFs now performs an additional
task: Verification of the validity of the recovered output shares. This process
ensures that aggregating the output shares will not lead to a garbled aggregate
result.<a href="#section-5-4" class="pilcrow">¶</a></p>
<p id="section-5-5">The remainder of this section defines the VDAF interface. The attributes are
listed in <a href="#vdaf-param" class="auto internal xref">Table 2</a> are defined by each concrete VDAF.<a href="#section-5-5" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-"></span><div id="vdaf-param">
<table class="center" id="table-2">
        <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-constants-and-types-defined-" class="selfRef">Constants and types defined by each concrete VDAF.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ID</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Algorithm identifier for this VDAF</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>VERIFY_KEY_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size (in bytes) of the verification key (<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>)</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the random byte string passed to sharding algorithm</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>NONCE_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size (in bytes) of the nonce</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ROUNDS</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of rounds of communication during the Preparation stage (<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>)</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>SHARES</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of input shares into which each measurement is sharded (<a href="#sec-vdaf-shard" class="auto internal xref">Section 5.1</a>)</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Measurement</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each measurement</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggParam</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of aggregation parameter</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Prep</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">State of each Aggregator during Preparation (<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>)</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OutShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each output share</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggResult</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-5-7">Similarly to DAFs (see {[sec-daf}}), any output of a VDAF method that must be
transmitted from one party to another is treated as an opaque byte string. All
other quantities are given a concrete type.<a href="#section-5-7" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-5-8.1">
          <p id="section-5-8.1.1">OPEN ISSUE It might be cleaner to define a type for each value, then have that
type implement an encoding where necessary. See issue#58.<a href="#section-5-8.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-5-9">Each VDAF is identified by a unique, 32-bit integer <code>ID</code>. Identifiers for each
(V)DAF specified in this document are defined in <a href="#codepoints" class="auto internal xref">Table 16</a>. The following
method is defined for every VDAF:<a href="#section-5-9" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-5-10">
<pre>
def custom(Vdaf, usage: Unsigned) -&gt; Bytes:
    return format_custom(0, Vdaf.ID, usage)
</pre><a href="#section-5-10" class="pilcrow">¶</a>
</div>
<p id="section-5-11">It is used to construct a customization string for an instance of <code>Prg</code> used by
the VDAF. (See <a href="#prg" class="auto internal xref">Section 6.2</a>.)<a href="#section-5-11" class="pilcrow">¶</a></p>
<div id="sec-vdaf-shard">
<section id="section-5.1">
        <h3 id="name-sharding-2">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-sharding-2" class="section-name selfRef">Sharding</a>
        </h3>
<p id="section-5.1-1">Sharding transforms a measurement into input shares as it does in DAFs
(cf. <a href="#sec-daf-shard" class="auto internal xref">Section 4.1</a>); in addition, it takes a nonce as input and
produces a public share:<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1">
            <p id="section-5.1-2.1.1"><code>Vdaf.measurement_to_input_shares(measurement: Measurement, nonce:
Bytes[Vdaf.NONCE_SIZE], rand: Bytes[Vdaf.RAND_SIZE]) -&gt; (Bytes, Vec[Bytes])</code>
is the randomized sharding algorithm run by each Client. (Input <code>rand</code>
consists of the random coins consumed by the algorithm.) It consumes the
measurement and the nonce and produces a public share, distributed to each of
Aggregators, and the corresponding sequence of input shares, one for each
Aggregator. Depending on the VDAF, the input shares may encode additional
information used to verify the recovered output shares (e.g., the "proof
shares" in Prio3 <a href="#prio3" class="auto internal xref">Section 7</a>). The length of the output vector <span class="bcp14">MUST</span> be <code>SHARES</code>.<a href="#section-5.1-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.1-3">In order to ensure privacy of the measurement, the Client <span class="bcp14">MUST</span> generate the
nonce using a cryptographically secure pseudorandom number generator (CSPRNG).
(See <a href="#security" class="auto internal xref">Section 9</a> for details.)<a href="#section-5.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-prepare">
<section id="section-5.2">
        <h3 id="name-preparation-2">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-preparation-2" class="section-name selfRef">Preparation</a>
        </h3>
<p id="section-5.2-1">To recover and verify output shares, the Aggregators interact with one another
over <code>ROUNDS</code> rounds. Prior to each round, each Aggregator constructs an
outbound message. Next, the sequence of outbound messages is combined into a
single message, called a "preparation message". (Each of the outbound messages
are called "preparation-message shares".) Finally, the preparation message is
distributed to the Aggregators to begin the next round.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">An Aggregator begins the first round with its input share and it begins each
subsequent round with the previous preparation message. Its output in the last
round is its output share and its output in each of the preceding rounds is a
preparation-message share.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2-3">This process involves a value called the "aggregation parameter" used to map the
input shares to output shares. The Aggregators need to agree on this parameter
before they can begin preparing inputs for aggregation.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<span id="name-vdaf-preparation-process-on"></span><div id="prep-flow">
<figure id="figure-6">
          <div class="alignLeft art-text artwork" id="section-5.2-4.1">
<pre>
    Aggregator 0   Aggregator 1        Aggregator SHARES-1
    ============   ============        ===================

    input_share_0  input_share_1       input_share_[SHARES-1]
      |              |              ...  |
      V              V                   V
    +-----------+  +-----------+       +-----------+
    | prep_init |  | prep_init |       | prep_init |
    +-----------+  +------------+      +-----------+
      |              |              ...  |             \
      V              V                   V             |
    +-----------+  +-----------+       +-----------+   |
    | prep_next |  | prep_next |       | prep_next |   |
    +-----------+  +-----------+       +-----------+   |
      |              |              ...  |             |
      V              V                   V             | x ROUNDS
    +----------------------------------------------+   |
    | prep_shares_to_prep                          |   |
    +----------------------------------------------+   |
                     |                                 |
      +--------------+-------------------+             |
      |              |              ...  |             |
      V              V                   V             /
     ...            ...                 ...
      |              |                   |
      V              V                   V
    +-----------+  +-----------+       +-----------+
    | prep_next |  | prep_next |       | prep_next |
    +-----------+  +-----------+       +-----------+
      |              |              ...  |
      V              V                   V
    out_share_0    out_share_1         out_share_[SHARES-1]
</pre>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-vdaf-preparation-process-on" class="selfRef">VDAF preparation process on the input shares for a single measurement. At the end of the computation, each Aggregator holds an output share or an error.</a>
          </figcaption></figure>
</div>
<p id="section-5.2-5">To facilitate the preparation process, a concrete VDAF implements the following
class methods:<a href="#section-5.2-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-6.1">
            <p id="section-5.2-6.1.1"><code>Vdaf.prep_init(verify_key: Bytes[Vdaf.VERIFY_KEY_SIZE], agg_id: Unsigned,
agg_param: AggParam, nonce: Bytes[Vdaf.NONCE_SIZE], public_share: Bytes,
input_share: Bytes) -&gt; Prep</code> is the deterministic preparation-state
initialization algorithm run by each Aggregator to begin processing its input
share into an output share. Its inputs are the shared verification key
(<code>verify_key</code>), the Aggregator's unique identifier (<code>agg_id</code>), the aggregation
parameter (<code>agg_param</code>), the nonce provided by the environment (<code>nonce</code>, see
<a href="#run-vdaf" class="auto internal xref">Figure 7</a>), the public share (<code>public_share</code>), and one of the input
shares generated by the client (<code>input_share</code>). Its output is the Aggregator's
initial preparation state.<a href="#section-5.2-6.1.1" class="pilcrow">¶</a></p>
<p id="section-5.2-6.1.2">
It is up to the high level protocol in which the VDAF is used to arrange for
the distribution of the verification key prior to generating and processing
reports. (See <a href="#security" class="auto internal xref">Section 9</a> for details.)<a href="#section-5.2-6.1.2" class="pilcrow">¶</a></p>
<p id="section-5.2-6.1.3">
Protocols using the VDAF <span class="bcp14">MUST</span> ensure that the Aggregator's identifier is equal
to the integer in range <code>[0, SHARES)</code> that matches the index of <code>input_share</code>
in the sequence of input shares output by the Client.<a href="#section-5.2-6.1.3" class="pilcrow">¶</a></p>
<p id="section-5.2-6.1.4">
Protocols <span class="bcp14">MUST</span> ensure that public share consumed by each of the Aggregators is
identical. This is security critical for VDAFs such as Poplar1 that require an
extractable distributed point function. (See <a href="#poplar1" class="auto internal xref">Section 8</a> for details.)<a href="#section-5.2-6.1.4" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-5.2-6.2">
            <p id="section-5.2-6.2.1"><code>Vdaf.prep_next(prep: Prep, inbound: Optional[Bytes]) -&gt; Union[Tuple[Prep,
Bytes], OutShare]</code> is the deterministic preparation-state update algorithm run
by each Aggregator. It updates the Aggregator's preparation state (<code>prep</code>) and
returns either its next preparation state and its message share for the
current round or, if this is the last round, its output share. An exception is
raised if a valid output share could not be recovered. The input of this
algorithm is the inbound preparation message or, if this is the first round,
<code>None</code>.<a href="#section-5.2-6.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-5.2-6.3">
            <p id="section-5.2-6.3.1"><code>Vdaf.prep_shares_to_prep(agg_param: AggParam, prep_shares: Vec[Bytes]) -&gt;
Bytes</code> is the deterministic preparation-message pre-processing algorithm. It
combines the preparation-message shares generated by the Aggregators in the
previous round into the preparation message consumed by each in the next
round.<a href="#section-5.2-6.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.2-7">In effect, each Aggregator moves through a linear state machine with <code>ROUNDS+1</code>
states.  The Aggregator enters the first state on using the initialization
algorithm, and the update algorithm advances the Aggregator to the next state.
Thus, in addition to defining the number of rounds (<code>ROUNDS</code>), a VDAF instance
defines the state of the Aggregator after each round.<a href="#section-5.2-7" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-5.2-8.1">
            <p id="section-5.2-8.1.1">TODO Consider how to bake this "linear state machine" condition into the
syntax. Given that Python 3 is used as our pseudocode, it's easier to specify
the preparation state using a class.<a href="#section-5.2-8.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.2-9">The preparation-state update accomplishes two tasks: recovery of output shares
from the input shares and ensuring that the recovered output shares are valid.
The abstraction boundary is drawn so that an Aggregator only recovers an output
share if it is deemed valid (at least, based on the Aggregator's view of the
protocol). Another way to draw this boundary would be to have the Aggregators
recover output shares first, then verify that they are valid. However, this
would allow the possibility of misusing the API by, say, aggregating an invalid
output share. Moreover, in protocols like Prio+ <span>[<a href="#AGJOP21" class="cite xref">AGJOP21</a>]</span> based on oblivious
transfer, it is necessary for the Aggregators to interact in order to recover
aggregatable output shares at all.<a href="#section-5.2-9" class="pilcrow">¶</a></p>
<p id="section-5.2-10">Note that it is possible for a VDAF to specify <code>ROUNDS == 0</code>, in which case each
Aggregator runs the preparation-state update algorithm once and immediately
recovers its output share without interacting with the other Aggregators.
However, most, if not all, constructions will require some amount of interaction
in order to ensure validity of the output shares (while also maintaining
privacy).<a href="#section-5.2-10" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-5.2-11.1">
            <p id="section-5.2-11.1.1">OPEN ISSUE accommodating 0-round VDAFs may require syntax changes if, for
example, public keys are required. On the other hand, we could consider
defining this class of schemes as a different primitive. See issue#77.<a href="#section-5.2-11.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec-vdaf-validity-scopes">
<section id="section-5.3">
        <h3 id="name-validity-of-aggregation-para">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-validity-of-aggregation-para" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-5.3-1">Similar to DAFs (see <a href="#sec-daf-validity-scopes" class="auto internal xref">Section 4.3</a>), VDAFs <span class="bcp14">MAY</span> impose
restrictions for input shares and aggregation parameters. Protocols using a VDAF
<span class="bcp14">MUST</span> ensure that for each input share and aggregation parameter <code>agg_param</code>, the
preparation phase (including <code>Vdaf.prep_init</code>, <code>Vdaf.prep_next</code>, and
<code>Vdaf.prep_shares_to_prep</code>; see <a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>) is only called if
<code>Vdaf.is_valid(agg_param, previous_agg_params)</code> returns True, where
<code>previous_agg_params</code> contains all aggregation parameters that have previously
been used with the same input share.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">VDAFs <span class="bcp14">MUST</span> implement the following function:<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.3-3.1">
            <p id="section-5.3-3.1.1"><code>Vdaf.is_valid(agg_param: AggParam, previous_agg_params: Vec[AggParam]) -&gt;
Bool</code>: Checks if the <code>agg_param</code> is compatible with all elements of
<code>previous_agg_params</code>.<a href="#section-5.3-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec-vdaf-aggregate">
<section id="section-5.4">
        <h3 id="name-aggregation-2">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-aggregation-2" class="section-name selfRef">Aggregation</a>
        </h3>
<p id="section-5.4-1">VDAF Aggregation is identical to DAF Aggregation (cf. <a href="#sec-daf-aggregate" class="auto internal xref">Section 4.4</a>):<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.4-2.1">
            <p id="section-5.4-2.1.1"><code>Vdaf.out_shares_to_agg_share(agg_param: AggParam, out_shares: Vec[OutShare])
-&gt; agg_share: Bytes</code> is the deterministic aggregation algorithm. It is run by
each Aggregator over the output shares it has computed over a batch of
measurement inputs.<a href="#section-5.4-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.4-3">The data flow for this stage is illustrated in <a href="#aggregate-flow" class="auto internal xref">Figure 3</a>. Here again,
we have the aggregation algorithm in a "one-shot" form, where all shares for a
batch are provided at the same time. VDAFs typically also support a "streaming"
form, where shares are processed one at a time.<a href="#section-5.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-unshard">
<section id="section-5.5">
        <h3 id="name-unsharding-2">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-unsharding-2" class="section-name selfRef">Unsharding</a>
        </h3>
<p id="section-5.5-1">VDAF Unsharding is identical to DAF Unsharding (cf. <a href="#sec-daf-unshard" class="auto internal xref">Section 4.5</a>):<a href="#section-5.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.5-2.1">
            <p id="section-5.5-2.1.1"><code>Vdaf.agg_shares_to_result(agg_param: AggParam,
agg_shares: Vec[Bytes], num_measurements: Unsigned) -&gt; AggResult</code> is
run by the Collector in order to compute the aggregate result from
the Aggregators' shares. The length of <code>agg_shares</code> <span class="bcp14">MUST</span> be <code>SHARES</code>.
<code>num_measurements</code> is the number of measurements that contributed to
each of the aggregate shares. This algorithm is deterministic.<a href="#section-5.5-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.5-3">The data flow for this stage is illustrated in <a href="#unshard-flow" class="auto internal xref">Figure 4</a>.<a href="#section-5.5-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="vdaf-execution">
<section id="section-5.6">
        <h3 id="name-execution-of-a-vdaf">
<a href="#section-5.6" class="section-number selfRef">5.6. </a><a href="#name-execution-of-a-vdaf" class="section-name selfRef">Execution of a VDAF</a>
        </h3>
<p id="section-5.6-1">Secure execution of a VDAF involves simulating the following procedure.<a href="#section-5.6-1" class="pilcrow">¶</a></p>
<span id="name-execution-of-a-vdaf-2"></span><div id="run-vdaf">
<figure id="figure-7">
          <div class="alignLeft art-text artwork" id="section-5.6-2.1">
<pre>
def run_vdaf(Vdaf,
             verify_key: Bytes[Vdaf.VERIFY_KEY_SIZE],
             agg_param: Vdaf.AggParam,
             nonces: Vec[Bytes[Vdaf.NONCE_SIZE]],
             measurements: Vec[Vdaf.Measurement]):
    out_shares = []
    for (nonce, measurement) in zip(nonces, measurements):
        # Each Client shards its measurement into input shares.
        rand = gen_rand(Vdaf.RAND_SIZE)
        (public_share, input_shares) = \
            Vdaf.measurement_to_input_shares(measurement, nonce, rand)

        # Each Aggregator initializes its preparation state.
        prep_states = []
        for j in range(Vdaf.SHARES):
            state = Vdaf.prep_init(verify_key, j,
                                   agg_param,
                                   nonce,
                                   public_share,
                                   input_shares[j])
            prep_states.append(state)

        # Aggregators recover their output shares.
        inbound = None
        for i in range(Vdaf.ROUNDS+1):
            outbound = []
            for j in range(Vdaf.SHARES):
                out = Vdaf.prep_next(prep_states[j], inbound)
                if i &lt; Vdaf.ROUNDS:
                    (prep_states[j], out) = out
                outbound.append(out)
            # This is where we would send messages over the
            # network in a distributed VDAF computation.
            if i &lt; Vdaf.ROUNDS:
                inbound = Vdaf.prep_shares_to_prep(agg_param,
                                                   outbound)

        # The final outputs of prepare phase are the output shares.
        out_shares.append(outbound)

    # Each Aggregator aggregates its output shares into an
    # aggregate share. In a distributed VDAF computation, the
    # aggregate shares are sent over the network.
    agg_shares = []
    for j in range(Vdaf.SHARES):
        out_shares_j = [out[j] for out in out_shares]
        agg_share_j = Vdaf.out_shares_to_agg_share(agg_param,
                                                   out_shares_j)
        agg_shares.append(agg_share_j)

    # Collector unshards the aggregate.
    num_measurements = len(measurements)
    agg_result = Vdaf.agg_shares_to_result(agg_param, agg_shares,
                                           num_measurements)
    return agg_result
</pre>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-execution-of-a-vdaf-2" class="selfRef">Execution of a VDAF.</a>
          </figcaption></figure>
</div>
<p id="section-5.6-3">The inputs to this algorithm are the aggregation parameter, a list of
measurements, and a nonce for each measurement. This document does not specify
how the nonces are chosen, but security requires that the nonces be unique. See
<a href="#security" class="auto internal xref">Section 9</a> for details. As explained in <a href="#daf-execution" class="auto internal xref">Section 4.6</a>, the secure
execution of a VDAF requires the application to instantiate secure channels
between each of the protocol participants.<a href="#section-5.6-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prelim">
<section id="section-6">
      <h2 id="name-preliminaries">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-preliminaries" class="section-name selfRef">Preliminaries</a>
      </h2>
<p id="section-6-1">This section describes the primitives that are common to the VDAFs specified in
this document.<a href="#section-6-1" class="pilcrow">¶</a></p>
<div id="field">
<section id="section-6.1">
        <h3 id="name-finite-fields">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-finite-fields" class="section-name selfRef">Finite Fields</a>
        </h3>
<p id="section-6.1-1">Both Prio3 and Poplar1 use finite fields of prime order. Finite field
elements are represented by a class <code>Field</code> with the following associated
parameters:<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-2.1">
            <p id="section-6.1-2.1.1"><code>MODULUS: Unsigned</code> is the prime modulus that defines the field.<a href="#section-6.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.1-2.2">
            <p id="section-6.1-2.2.1"><code>ENCODED_SIZE: Unsigned</code> is the number of bytes used to encode a field element
as a byte string.<a href="#section-6.1-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-3">A concrete <code>Field</code> also implements the following class methods:<a href="#section-6.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1">
            <p id="section-6.1-4.1.1"><code>Field.zeros(length: Unsigned) -&gt; output: Vec[Field]</code> returns a vector of
zeros. The length of <code>output</code> <span class="bcp14">MUST</span> be <code>length</code>.<a href="#section-6.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.1-4.2">
            <p id="section-6.1-4.2.1"><code>Field.rand_vec(length: Unsigned) -&gt; output: Vec[Field]</code> returns a vector of
random field elements. The length of <code>output</code> <span class="bcp14">MUST</span> be <code>length</code>.<a href="#section-6.1-4.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-5">A field element is an instance of a concrete <code>Field</code>. The concrete class defines
the usual arithmetic operations on field elements. In addition, it defines the
following instance method for converting a field element to an unsigned integer:<a href="#section-6.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-6.1">
            <p id="section-6.1-6.1.1"><code>elem.as_unsigned() -&gt; Unsigned</code> returns the integer representation of
field element <code>elem</code>.<a href="#section-6.1-6.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-7">Likewise, each concrete <code>Field</code> implements a constructor for converting an
unsigned integer into a field element:<a href="#section-6.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-8.1">
            <p id="section-6.1-8.1.1"><code>Field(integer: Unsigned)</code> returns <code>integer</code> represented as a field element.
The value of <code>integer</code> <span class="bcp14">MUST</span> be less than <code>Field.MODULUS</code>.<a href="#section-6.1-8.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-9">Finally, each concrete <code>Field</code> has two derived class methods, one for encoding
a vector of field elements as a byte string and another for decoding a vector of
field elements.<a href="#section-6.1-9" class="pilcrow">¶</a></p>
<span id="name-derived-class-methods-for-f"></span><div id="field-derived-methods">
<figure id="figure-8">
          <div class="alignLeft art-text artwork" id="section-6.1-10.1">
<pre>
def encode_vec(Field, data: Vec[Field]) -&gt; Bytes:
    encoded = Bytes()
    for x in data:
        encoded += to_le_bytes(x.as_unsigned(), Field.ENCODED_SIZE)
    return encoded

def decode_vec(Field, encoded: Bytes) -&gt; Vec[Field]:
    L = Field.ENCODED_SIZE
    if len(encoded) % L != 0:
        raise ERR_DECODE

    vec = []
    for i in range(0, len(encoded), L):
        encoded_x = encoded[i:i+L]
        x = from_le_bytes(encoded_x)
        if x &gt;= Field.MODULUS:
            raise ERR_DECODE # Integer is larger than modulus
        vec.append(Field(x))
    return vec
</pre>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-derived-class-methods-for-f" class="selfRef">Derived class methods for finite fields.</a>
          </figcaption></figure>
</div>
<div id="auxiliary-functions">
<section id="section-6.1.1">
          <h4 id="name-auxiliary-functions">
<a href="#section-6.1.1" class="section-number selfRef">6.1.1. </a><a href="#name-auxiliary-functions" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<p id="section-6.1.1-1">The following auxiliary functions on vectors of field elements are used in the
remainder of this document. Note that an exception is raised by each function if
the operands are not the same length.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
<span id="name-common-functions-for-finite"></span><div id="field-helper-functions">
<figure id="figure-9">
            <div class="alignLeft art-text artwork" id="section-6.1.1-2.1">
<pre>
# Compute the inner product of the operands.
def inner_product(left: Vec[Field], right: Vec[Field]) -&gt; Field:
    return sum(map(lambda x: x[0] * x[1], zip(left, right)))

# Subtract the right operand from the left and return the result.
def vec_sub(left: Vec[Field], right: Vec[Field]):
    return list(map(lambda x: x[0] - x[1], zip(left, right)))

# Add the right operand to the left and return the result.
def vec_add(left: Vec[Field], right: Vec[Field]):
    return list(map(lambda x: x[0] + x[1], zip(left, right)))
</pre>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-common-functions-for-finite" class="selfRef">Common functions for finite fields.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="field-fft-friendly">
<section id="section-6.1.2">
          <h4 id="name-fft-friendly-fields">
<a href="#section-6.1.2" class="section-number selfRef">6.1.2. </a><a href="#name-fft-friendly-fields" class="section-name selfRef">FFT-Friendly Fields</a>
          </h4>
<p id="section-6.1.2-1">Some VDAFs require fields that are suitable for efficient computation of the
discrete Fourier transform, as this allows for fast polynomial interpolation.
(One example is Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) when instantiated with the generic FLP of
<a href="#flp-generic-construction" class="auto internal xref">Section 7.3.3</a>.) Specifically, a field is said to be
"FFT-friendly" if, in addition to satisfying the interface described in
<a href="#field" class="auto internal xref">Section 6.1</a>, it implements the following method:<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-2.1">
              <p id="section-6.1.2-2.1.1"><code>Field.gen() -&gt; Field</code> returns the generator of a large subgroup of the
multiplicative group. To be FFT-friendly, the order of this subgroup <span class="bcp14">MUST</span> be a
power of 2. In addition, the size of the subgroup dictates how large
interpolated polynomials can be. It is <span class="bcp14">RECOMMENDED</span> that a generator is chosen
with order at least <code>2^20</code>.<a href="#section-6.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.2-3">FFT-friendly fields also define the following parameter:<a href="#section-6.1.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-4.1">
              <p id="section-6.1.2-4.1.1"><code>GEN_ORDER: Unsigned</code> is the order of a multiplicative subgroup generated by
<code>Field.gen()</code>.<a href="#section-6.1.2-4.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</section>
</div>
<div id="parameters">
<section id="section-6.1.3">
          <h4 id="name-parameters">
<a href="#section-6.1.3" class="section-number selfRef">6.1.3. </a><a href="#name-parameters" class="section-name selfRef">Parameters</a>
          </h4>
<p id="section-6.1.3-1">The tables below define finite fields used in the remainder of this document.<a href="#section-6.1.3-1" class="pilcrow">¶</a></p>
<span id="name-parameters-for-the-finite-f"></span><div id="fields">
<table class="center" id="table-3">
            <caption>
<a href="#table-3" class="selfRef">Table 3</a>:
<a href="#name-parameters-for-the-finite-f" class="selfRef">Parameters for the finite fields used in this document.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Field64</th>
                <th class="text-left" rowspan="1" colspan="1">Field128</th>
                <th class="text-left" rowspan="1" colspan="1">Field255</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">MODULUS</td>
                <td class="text-left" rowspan="1" colspan="1">2^32 * 4294967295 + 1</td>
                <td class="text-left" rowspan="1" colspan="1">2^66 * 4611686018427387897 + 1</td>
                <td class="text-left" rowspan="1" colspan="1">2^255 - 19</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">ENCODED_SIZE</td>
                <td class="text-left" rowspan="1" colspan="1">8</td>
                <td class="text-left" rowspan="1" colspan="1">16</td>
                <td class="text-left" rowspan="1" colspan="1">32</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">Generator</td>
                <td class="text-left" rowspan="1" colspan="1">7^4294967295</td>
                <td class="text-left" rowspan="1" colspan="1">7^4611686018427387897</td>
                <td class="text-left" rowspan="1" colspan="1">n/a</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">GEN_ORDER</td>
                <td class="text-left" rowspan="1" colspan="1">2^32</td>
                <td class="text-left" rowspan="1" colspan="1">2^66</td>
                <td class="text-left" rowspan="1" colspan="1">n/a</td>
              </tr>
            </tbody>
          </table>
</div>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-6.1.3-3.1">
              <p id="section-6.1.3-3.1.1">OPEN ISSUE We currently use big-endian for encoding field elements. However,
for implementations of <code>GF(2^255-19)</code>, little endian is more common. See
issue#90.<a href="#section-6.1.3-3.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</section>
</div>
</section>
</div>
<div id="prg">
<section id="section-6.2">
        <h3 id="name-pseudorandom-generators">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-pseudorandom-generators" class="section-name selfRef">Pseudorandom Generators</a>
        </h3>
<p id="section-6.2-1">A pseudorandom generator (PRG) is used to expand a short, (pseudo)random seed
into a long string of pseudorandom bits. A PRG suitable for this document
implements the interface specified in this section.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">PRGs are defined by a class <code>Prg</code> with the following associated parameter:<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-3.1">
            <p id="section-6.2-3.1.1"><code>SEED_SIZE: Unsigned</code> is the size (in bytes) of a seed.<a href="#section-6.2-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.2-4">A concrete <code>Prg</code> implements the following class method:<a href="#section-6.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-5.1">
            <p id="section-6.2-5.1.1"><code>Prg(seed: Bytes[Prg.SEED_SIZE], custom: Bytes, binder: Bytes)</code> constructs an
instance of <code>Prg</code> from the given seed and customization and binder strings.
(See below for definitions of these.) The seed <span class="bcp14">MUST</span> be of length <code>SEED_SIZE</code>
and <span class="bcp14">MUST</span> be generated securely (i.e., it is either the output of <code>gen_rand</code> or
a previous invocation of the PRG).<a href="#section-6.2-5.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.2-5.2">
            <p id="section-6.2-5.2.1"><code>prg.next(length: Unsigned)</code> returns the next <code>length</code> bytes of output of PRG.
If the seed was securely generated, the output can be treated as pseudorandom.<a href="#section-6.2-5.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.2-6">Each <code>Prg</code> has two derived class methods. The first is used to derive a fresh
seed from an existing one. The second is used to compute a sequence of
pseudorandom field elements. For each method, the seed <span class="bcp14">MUST</span> be of length
<code>SEED_SIZE</code> and <span class="bcp14">MUST</span> be generated securely (i.e., it is either the output of
<code>gen_rand</code> or a previous invocation of the PRG).<a href="#section-6.2-6" class="pilcrow">¶</a></p>
<span id="name-derived-class-methods-for-p"></span><div id="prg-derived-methods">
<figure id="figure-10">
          <div class="alignLeft art-text artwork" id="section-6.2-7.1">
<pre>
# Derive a new seed.
def derive_seed(Prg, seed: Bytes[Prg.SEED_SIZE], custom: Bytes, binder: Bytes):
    prg = Prg(seed, custom, binder)
    return prg.next(Prg.SEED_SIZE)

# Output the next `length` pseudorandom elements of `Field`.
def next_vec(self, Field, length: Unsigned):
    m = next_power_of_2(Field.MODULUS) - 1
    vec = []
    while len(vec) &lt; length:
        x = from_le_bytes(self.next(Field.ENCODED_SIZE))
        x &amp;= m
        if x &lt; Field.MODULUS:
            vec.append(Field(x))
    return vec

# Expand the input `seed` into vector of `length` field elements.
def expand_into_vec(Prg,
                    Field,
                    seed: Bytes[Prg.SEED_SIZE],
                    custom: Bytes,
                    binder: Bytes,
                    length: Unsigned):
    prg = Prg(seed, custom, binder)
    return prg.next_vec(Field, length)
</pre>
</div>
<figcaption><a href="#figure-10" class="selfRef">Figure 10</a>:
<a href="#name-derived-class-methods-for-p" class="selfRef">Derived class methods for PRGs.</a>
          </figcaption></figure>
</div>
<div id="prg-sha3">
<section id="section-6.2.1">
          <h4 id="name-prgsha3">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-prgsha3" class="section-name selfRef">PrgSha3</a>
          </h4>
<p id="section-6.2.1-1">This section describes PrgSha3, a PRG based on the Keccak permutation of SHA-3
<span>[<a href="#FIPS202" class="cite xref">FIPS202</a>]</span>. Keccak is used in the cSHAKE128 mode of operation <span>[<a href="#SP800-185" class="cite xref">SP800-185</a>]</span>.
This Prg is <span class="bcp14">RECOMMENDED</span> for all use cases within VDAFs.<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<span id="name-definition-of-prg-prgsha3"></span><figure id="figure-11">
            <div class="alignLeft art-text artwork" id="section-6.2.1-2.1">
<pre>
class PrgSha3(Prg):
    # Associated parameters
    SEED_SIZE = 16

    def __init__(self, seed, custom, binder):
        self.l = 0
        self.x = seed + binder
        self.s = custom

    def next(self, length: Unsigned) -&gt; Bytes:
        self.l += length

        # Function `cSHAKE128(x, l, n, s)` is as defined in
        # [SP800-185, Section 3.3].
        #
        # Implementation note: Rather than re-generate the output
        # stream each time `next()` is invoked, most implementations
        # of SHA-3 will expose an "absorb-then-squeeze" API that
        # allows stateful handling of the stream.
        stream = cSHAKE128(self.x, self.l, b'', self.s)
        return stream[-length:]
</pre>
</div>
<figcaption><a href="#figure-11" class="selfRef">Figure 11</a>:
<a href="#name-definition-of-prg-prgsha3" class="selfRef">Definition of PRG PrgSha3.</a>
            </figcaption></figure>
</section>
</div>
<div id="prg-fixed-key-aes128">
<section id="section-6.2.2">
          <h4 id="name-prgfixedkeyaes128">
<a href="#section-6.2.2" class="section-number selfRef">6.2.2. </a><a href="#name-prgfixedkeyaes128" class="section-name selfRef">PrgFixedKeyAes128</a>
          </h4>
<p id="section-6.2.2-1">While PrgSha3 as described above can be securely used in all cases where a Prg
is needed in the VDAFs described in this document, there are some cases where
a more efficient instantiation based on fixed-key AES is possible. For now, this
is limited to the Prg used inside the Idpf <a href="#idpf" class="auto internal xref">Section 8.1</a> implementation in Poplar1
<a href="#idpf-poplar" class="auto internal xref">Section 8.3</a>. It is <span class="bcp14">NOT RECOMMENDED</span> to use this Prg anywhere else.
See Security Considerations <a href="#security" class="auto internal xref">Section 9</a> for a more detailed discussion.<a href="#section-6.2.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.2.2-2">
<pre>
class PrgFixedKeyAes128(Prg):
    # Associated parameters
    SEED_SIZE = 16

    def __init__(self, seed, custom, binder):
        self.length_consumed = 0

        # Use SHA-3 to derive a key from the binder and customization
        # strings. Note that the AES key does not need to be kept
        # secret from any party. However, when used with IdpfPoplar,
        # we require the binder to be a random nonce.
        #
        # Implementation note: This step can be cached across PRG
        # evaluations with many different seeds.
        self.fixed_key = cSHAKE128(binder, 16, b'', custom)
        self.seed = seed

    def next(self, length: Unsigned) -&gt; Bytes:
        offset = self.length_consumed % 16
        new_length = self.length_consumed + length
        block_range = range(
            int(self.length_consumed / 16),
            int(new_length / 16) + 1)
        self.length_consumed = new_length

        hashed_blocks = [
            self.hash_block(xor(self.seed, to_le_bytes(i, 16))) \
                         for i in block_range
        ]
        return concat(hashed_blocks)[offset:offset+length]

    # The multi-instance tweakable circular correlation-robust hash function of
    # [GKWWY20] (Section 4.2).
    #
    # Function `AES128(key, block)` is the AES-128 blockcipher.
    def hash_block(self, block):
        lo, hi = block[:8], block[8:]
        sigma = hi + xor(hi, lo)
        return xor(AES128(self.fixed_key, sigma), sigma)
</pre><a href="#section-6.2.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="the-customization-and-binder-strings">
<section id="section-6.2.3">
          <h4 id="name-the-customization-and-binde">
<a href="#section-6.2.3" class="section-number selfRef">6.2.3. </a><a href="#name-the-customization-and-binde" class="section-name selfRef">The Customization and Binder Strings</a>
          </h4>
<p id="section-6.2.3-1">PRGs are used to map a seed to a finite domain, e.g., a fresh seed or a vector
of field elements. To ensure domain separation, the derivation is needs to be
bound to some distinguished "customization string". The customization string
encodes the following values:<a href="#section-6.2.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-6.2.3-2">
<li id="section-6.2.3-2.1">
              <p id="section-6.2.3-2.1.1">The document version (i.e.,<code>VERSION</code>);<a href="#section-6.2.3-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.2">
              <p id="section-6.2.3-2.2.1">The "class" of the algorithm using the output (e.g., VDAF);<a href="#section-6.2.3-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.3">
              <p id="section-6.2.3-2.3.1">A unique identifier for the algorithm; and<a href="#section-6.2.3-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.4">
              <p id="section-6.2.3-2.4.1">Some indication of how the output is used (e.g., for deriving the measurement
shares in Prio3 <a href="#prio3" class="auto internal xref">Section 7</a>).<a href="#section-6.2.3-2.4.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-6.2.3-3">The following algorithm is used in the remainder of this document in order to
format the customization string:<a href="#section-6.2.3-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.2.3-4">
<pre>
def format_custom(algo_class: Unsigned,
                  algo: Unsigned,
                  usage: Unsigned) -&gt; Bytes:
    return to_be_bytes(VERSION, 1) + \
           to_be_bytes(algo_class, 1) + \
           to_be_bytes(algo, 4) + \
           to_be_bytes(usage, 2)
</pre><a href="#section-6.2.3-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2.3-5">It is also sometimes necessary to bind the output to some ephemeral value that
multiple parties need to agree on. We call this input the "binder string".<a href="#section-6.2.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="prio3">
<section id="section-7">
      <h2 id="name-prio3">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-prio3" class="section-name selfRef">Prio3</a>
      </h2>
<p id="section-7-1">This section describes Prio3, a VDAF for Prio <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>. Prio is suitable for
a wide variety of aggregation functions, including (but not limited to) sum,
mean, standard deviation, estimation of quantiles (e.g., median), and linear
regression. In fact, the scheme described in this section is compatible with any
aggregation function that has the following structure:<a href="#section-7-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1">
          <p id="section-7-2.1.1">Each measurement is encoded as a vector over some finite field.<a href="#section-7-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.2">
          <p id="section-7-2.2.1">Input validity is determined by an arithmetic circuit evaluated over the
encoded input. (An "arithmetic circuit" is a function comprised of arithmetic
operations in the field.) The circuit's output is a single field element: if
zero, then the input is said to be "valid"; otherwise, if the output is
non-zero, then the input is said to be "invalid".<a href="#section-7-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.3">
          <p id="section-7-2.3.1">The aggregate result is obtained by summing up the encoded input vectors and
computing some function of the sum.<a href="#section-7-2.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-7-3">At a high level, Prio3 distributes this computation as follows. Each Client
first shards its measurement by first encoding it, then splitting the vector into
secret shares and sending a share to each Aggregator. Next, in the preparation
phase, the Aggregators carry out a multi-party computation to determine if their
shares correspond to a valid input (as determined by the arithmetic circuit).
This computation involves a "proof" of validity generated by the Client. Next,
each Aggregator sums up its input shares locally. Finally, the Collector sums up
the aggregate shares and computes the aggregate result.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">This VDAF does not have an aggregation parameter. Instead, the output share is
derived from the input share by applying a fixed map. See <a href="#poplar1" class="auto internal xref">Section 8</a> for an
example of a VDAF that makes meaningful use of the aggregation parameter.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">As the name implies, Prio3 is a descendant of the original Prio construction.
A second iteration was deployed in the <span>[<a href="#ENPA" class="cite xref">ENPA</a>]</span> system, and like the VDAF
described here, the ENPA system was built from techniques introduced in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> that significantly improve communication cost. That system was
specialized for a particular aggregation function; the goal of Prio3 is to
provide the same level of generality as the original construction.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">The core component of Prio3 is a "Fully Linear Proof (FLP)" system. Introduced
by <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, the FLP encapsulates the functionality required for encoding
and validating inputs. Prio3 can be thought of as a transformation of a
particular class of FLPs into a VDAF.<a href="#section-7-6" class="pilcrow">¶</a></p>
<p id="section-7-7">The remainder of this section is structured as follows. The syntax for FLPs is
described in <a href="#flp" class="auto internal xref">Section 7.1</a>. The generic transformation of an FLP into Prio3 is
specified in <a href="#prio3-construction" class="auto internal xref">Section 7.2</a>. Next, a concrete FLP suitable for any
validity circuit is specified in <a href="#flp-generic" class="auto internal xref">Section 7.3</a>. Finally, instantiations of
Prio3 for various types of measurements are specified in
<a href="#prio3-instantiations" class="auto internal xref">Section 7.4</a>. Test vectors can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-7-7" class="pilcrow">¶</a></p>
<div id="flp">
<section id="section-7.1">
        <h3 id="name-fully-linear-proof-flp-syst">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-fully-linear-proof-flp-syst" class="section-name selfRef">Fully Linear Proof (FLP) Systems</a>
        </h3>
<p id="section-7.1-1">Conceptually, an FLP is a two-party protocol executed by a prover and a
verifier. In actual use, however, the prover's computation is carried out by the
Client, and the verifier's computation is distributed among the Aggregators. The
Client generates a "proof" of its input's validity and distributes shares of the
proof to the Aggregators. Each Aggregator then performs some a computation on
its input share and proof share locally and sends the result to the other
Aggregators. Combining the exchanged messages allows each Aggregator to decide
if it holds a share of a valid input. (See <a href="#prio3-construction" class="auto internal xref">Section 7.2</a> for details.)<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">As usual, we will describe the interface implemented by a concrete FLP in terms
of an abstract base class <code>Flp</code> that specifies the set of methods and parameters
a concrete FLP must provide.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
<p id="section-7.1-3">The parameters provided by a concrete FLP are listed in <a href="#flp-param" class="auto internal xref">Table 4</a>.<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-b"></span><div id="flp-param">
<table class="center" id="table-4">
          <caption>
<a href="#table-4" class="selfRef">Table 4</a>:
<a href="#name-constants-and-types-defined-b" class="selfRef">Constants and types defined by a concrete FLP.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROVE_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the prover randomness, the number of random field elements consumed by the prover when generating a proof</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>QUERY_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the query randomness, the number of random field elements consumed by the verifier</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>JOINT_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the joint randomness, the number of random field elements consumed by both the prover and verifier</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>INPUT_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the encoded measurement (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OUTPUT_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the aggregatable output (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROOF_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the proof</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFIER_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the verifier message generated by querying the input and proof</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of the measurement</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As defined in (<a href="#field" class="auto internal xref">Section 6.1</a>)</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-7.1-5">An FLP specifies the following algorithms for generating and verifying proofs of
validity (encoding is described below in <a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>):<a href="#section-7.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-6.1">
            <p id="section-7.1-6.1.1"><code>Flp.prove(input: Vec[Field], prove_rand: Vec[Field], joint_rand: Vec[Field])
-&gt; Vec[Field]</code> is the deterministic proof-generation algorithm run by the
prover. Its inputs are the encoded input, the "prover randomness"
<code>prove_rand</code>, and the "joint randomness" <code>joint_rand</code>. The prover randomness is
used only by the prover, but the joint randomness is shared by both the prover
and verifier.<a href="#section-7.1-6.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-7.1-6.2">
            <p id="section-7.1-6.2.1"><code>Flp.query(input: Vec[Field], proof: Vec[Field], query_rand: Vec[Field],
joint_rand: Vec[Field], num_shares: Unsigned) -&gt; Vec[Field]</code> is the
query-generation algorithm run by the verifier. This is used to "query" the
input and proof. The result of the query (i.e., the output of this function)
is called the "verifier message". In addition to the input and proof, this
algorithm takes as input the query randomness <code>query_rand</code> and the joint
randomness <code>joint_rand</code>. The former is used only by the verifier. <code>num_shares</code>
specifies how many input and proof shares were generated.<a href="#section-7.1-6.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-7.1-6.3">
            <p id="section-7.1-6.3.1"><code>Flp.decide(verifier: Vec[Field]) -&gt; Bool</code> is the deterministic decision
algorithm run by the verifier. It takes as input the verifier message and
outputs a boolean indicating if the input from which it was generated is
valid.<a href="#section-7.1-6.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-7.1-7">Our application requires that the FLP is "fully linear" in the sense defined in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>. As a practical matter, what this property implies is that, when
run on a share of the input and proof, the query-generation algorithm outputs a
share of the verifier message. Furthermore, the "strong zero-knowledge" property
of the FLP system ensures that the verifier message reveals nothing about the
input's validity. Therefore, to decide if an input is valid, the Aggregators
will run the query-generation algorithm locally, exchange verifier shares,
combine them to recover the verifier message, and run the decision algorithm.<a href="#section-7.1-7" class="pilcrow">¶</a></p>
<p id="section-7.1-8">The query-generation algorithm includes a parameter <code>num_shares</code> that specifies
the number of shares of the input and proof that were generated. If these data
are not secret shared, then <code>num_shares == 1</code>. This parameter is useful for
certain FLP constructions. For example, the FLP in <a href="#flp-generic" class="auto internal xref">Section 7.3</a> is defined in
terms of an arithmetic circuit; when the circuit contains constants, it is
sometimes necessary to normalize those constants to ensure that the circuit's
output, when run on a valid input, is the same regardless of the number of
shares.<a href="#section-7.1-8" class="pilcrow">¶</a></p>
<p id="section-7.1-9">An FLP is executed by the prover and verifier as follows:<a href="#section-7.1-9" class="pilcrow">¶</a></p>
<span id="name-execution-of-an-flp"></span><div id="run-flp">
<figure id="figure-12">
          <div class="alignLeft art-text artwork" id="section-7.1-10.1">
<pre>
def run_flp(Flp, inp: Vec[Flp.Field], num_shares: Unsigned):
    joint_rand = Flp.Field.rand_vec(Flp.JOINT_RAND_LEN)
    prove_rand = Flp.Field.rand_vec(Flp.PROVE_RAND_LEN)
    query_rand = Flp.Field.rand_vec(Flp.QUERY_RAND_LEN)

    # Prover generates the proof.
    proof = Flp.prove(inp, prove_rand, joint_rand)

    # Verifier queries the input and proof.
    verifier = Flp.query(inp, proof, query_rand, joint_rand, num_shares)

    # Verifier decides if the input is valid.
    return Flp.decide(verifier)
</pre>
</div>
<figcaption><a href="#figure-12" class="selfRef">Figure 12</a>:
<a href="#name-execution-of-an-flp" class="selfRef">Execution of an FLP.</a>
          </figcaption></figure>
</div>
<p id="section-7.1-11">The proof system is constructed so that, if <code>input</code> is a valid input, then
<code>run_flp(Flp, input, 1)</code> always returns <code>True</code>. On the other hand, if <code>input</code> is
invalid, then as long as <code>joint_rand</code> and <code>query_rand</code> are generated uniform
randomly, the output is <code>False</code> with overwhelming probability.<a href="#section-7.1-11" class="pilcrow">¶</a></p>
<p id="section-7.1-12">We remark that <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> defines a much larger class of fully linear proof
systems than we consider here. In particular, what is called an "FLP" here is
called a 1.5-round, public-coin, interactive oracle proof system in their paper.<a href="#section-7.1-12" class="pilcrow">¶</a></p>
<div id="flp-encode">
<section id="section-7.1.1">
          <h4 id="name-encoding-the-input">
<a href="#section-7.1.1" class="section-number selfRef">7.1.1. </a><a href="#name-encoding-the-input" class="section-name selfRef">Encoding the Input</a>
          </h4>
<p id="section-7.1.1-1">The type of measurement being aggregated is defined by the FLP. Hence, the FLP
also specifies a method of encoding raw measurements as a vector of field
elements:<a href="#section-7.1.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-2.1">
              <p id="section-7.1.1-2.1.1"><code>Flp.encode(measurement: Measurement) -&gt; Vec[Field]</code> encodes a raw measurement
as a vector of field elements. The return value <span class="bcp14">MUST</span> be of length <code>INPUT_LEN</code>.<a href="#section-7.1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.1.1-3">For some FLPs, the encoded input also includes redundant field elements that are
useful for checking the proof, but which are not needed after the proof has been
checked. An example is the "integer sum" data type from <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span> in which an
integer in range <code>[0, 2^k)</code> is encoded as a vector of <code>k</code> field elements (this
type is also defined in <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>). After consuming this vector, all that is
needed is the integer it represents. Thus the FLP defines an algorithm for
truncating the input to the length of the aggregated output:<a href="#section-7.1.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-4.1">
              <p id="section-7.1.1-4.1.1"><code>Flp.truncate(input: Vec[Field]) -&gt; Vec[Field]</code> maps an encoded input to an
aggregatable output. The length of the input <span class="bcp14">MUST</span> be <code>INPUT_LEN</code> and the length
of the output <span class="bcp14">MUST</span> be <code>OUTPUT_LEN</code>.<a href="#section-7.1.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.1.1-5">Once the aggregate shares have been computed and combined together, their sum
can be converted into the aggregate result. This could be a projection from
the FLP's field to the integers, or it could include additional
post-processing.<a href="#section-7.1.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-6.1">
              <p id="section-7.1.1-6.1.1"><code>Flp.decode(output: Vec[Field], num_measurements: Unsigned) -&gt; AggResult</code>
maps a sum of aggregate shares to an aggregate result. The length of the
input <span class="bcp14">MUST</span> be <code>OUTPUT_LEN</code>. <code>num_measurements</code> is the number of measurements
that contributed to the aggregated output.<a href="#section-7.1.1-6.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.1.1-7">We remark that, taken together, these three functionalities correspond roughly
to the notion of "Affine-aggregatable encodings (AFEs)" from <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>.<a href="#section-7.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prio3-construction">
<section id="section-7.2">
        <h3 id="name-construction">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-construction" class="section-name selfRef">Construction</a>
        </h3>
<p id="section-7.2-1">This section specifies <code>Prio3</code>, an implementation of the <code>Vdaf</code> interface
(<a href="#vdaf" class="auto internal xref">Section 5</a>). It has two generic parameters: an <code>Flp</code> (<a href="#flp" class="auto internal xref">Section 7.1</a>) and a <code>Prg</code>
(<a href="#prg" class="auto internal xref">Section 6.2</a>). The associated constants and types required by the <code>Vdaf</code> interface
are defined in <a href="#prio3-param" class="auto internal xref">Table 5</a>. The methods required for sharding, preparation,
aggregation, and unsharding are described in the remaining subsections. These
methods refer to constants enumerated in <a href="#prio3-const" class="auto internal xref">Table 6</a>.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<span id="name-vdaf-parameters-for-prio3"></span><div id="prio3-param">
<table class="center" id="table-5">
          <caption>
<a href="#table-5" class="selfRef">Table 5</a>:
<a href="#name-vdaf-parameters-for-prio3" class="selfRef">VDAF parameters for Prio3.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFY_KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Prg.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>16</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>ROUNDS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>1</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">in <code>[2, 256)</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Flp.Measurement</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggParam</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>None</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Prep</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Tuple[Vec[Flp.Field], Optional[Bytes], Bytes]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OutShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Vec[Flp.Field]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Flp.AggResult</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<span id="name-constants-used-by-prio3"></span><div id="prio3-const">
<table class="center" id="table-6">
          <caption>
<a href="#table-6" class="selfRef">Table 6</a>:
<a href="#name-constants-used-by-prio3" class="selfRef">Constants used by Prio3.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Variable</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_MEASUREMENT_SHARE: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_PROOF_SHARE: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_JOINT_RANDOMNESS: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_PROVE_RANDOMNESS: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_QUERY_RANDOMNESS: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">5</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_JOINT_RAND_SEED: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>DST_JOINT_RAND_PART: Unsigned</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">7</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="sharding">
<section id="section-7.2.1">
          <h4 id="name-sharding-3">
<a href="#section-7.2.1" class="section-number selfRef">7.2.1. </a><a href="#name-sharding-3" class="section-name selfRef">Sharding</a>
          </h4>
<p id="section-7.2.1-1">Recall from <a href="#flp" class="auto internal xref">Section 7.1</a> that the FLP syntax calls for "joint randomness" shared by
the prover (i.e., the Client) and the verifier (i.e., the Aggregators). VDAFs
have no such notion. Instead, the Client derives the joint randomness from its
input in a way that allows the Aggregators to reconstruct it from their input
shares. (This idea is based on the Fiat-Shamir heuristic and is described in
Section 6.2.3 of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>.)<a href="#section-7.2.1-1" class="pilcrow">¶</a></p>
<p id="section-7.2.1-2">The sharding algorithm involves the following steps:<a href="#section-7.2.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1-3">
<li id="section-7.2.1-3.1">
              <p id="section-7.2.1-3.1.1">Encode the Client's raw measurement as an input for the FLP<a href="#section-7.2.1-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.2">
              <p id="section-7.2.1-3.2.1">Shard the input into a sequence of input shares<a href="#section-7.2.1-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.3">
              <p id="section-7.2.1-3.3.1">Derive the joint randomness from the input shares and nonce<a href="#section-7.2.1-3.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.4">
              <p id="section-7.2.1-3.4.1">Run the FLP proof-generation algorithm using the derived joint randomness<a href="#section-7.2.1-3.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.5">
              <p id="section-7.2.1-3.5.1">Shard the proof into a sequence of proof shares<a href="#section-7.2.1-3.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-7.2.1-4">The algorithm is specified below. Notice that only one set of input and proof
shares (called the "leader" shares below) are vectors of field elements. The
other shares (called the "helper" shares) are represented instead by PRG seeds,
which are expanded into vectors of field elements.<a href="#section-7.2.1-4" class="pilcrow">¶</a></p>
<p id="section-7.2.1-5">The definitions of constants and a few auxiliary functions are defined in
<a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>.<a href="#section-7.2.1-5" class="pilcrow">¶</a></p>
<span id="name-input-distribution-algorith"></span><div id="prio3-eval-input">
<figure id="figure-13">
            <div class="alignLeft art-text artwork" id="section-7.2.1-6.1">
<pre>
def measurement_to_input_shares(Prio3, measurement, nonce, rand):
    l = Prio3.Prg.SEED_SIZE
    use_joint_rand = Prio3.Flp.JOINT_RAND_LEN &gt; 0

    # Split the coins into the various seeds we'll need.
    if len(rand) != Prio3.RAND_SIZE:
        raise ERR_INPUT # unexpected length for random coins
    seeds = [rand[i:i+l] for i in range(0,Prio3.RAND_SIZE,l)]
    if use_joint_rand:
        k_helper_seeds, seeds = front((Prio3.SHARES-1) * 3, seeds)
        k_helper_meas_shares = [
            k_helper_seeds[i]
            for i in range(0, (Prio3.SHARES-1) * 3, 3)
        ]
        k_helper_proof_shares = [
            k_helper_seeds[i]
            for i in range(1, (Prio3.SHARES-1) * 3, 3)
        ]
        k_helper_blinds = [
            k_helper_seeds[i]
            for i in range(2, (Prio3.SHARES-1) * 3, 3)
        ]
        (k_leader_blind,), seeds = front(1, seeds)
    else:
        k_helper_seeds, seeds = front((Prio3.SHARES-1) * 2, seeds)
        k_helper_meas_shares = [
            k_helper_seeds[i]
            for i in range(0, (Prio3.SHARES-1) * 2, 2)
        ]
        k_helper_proof_shares = [
            k_helper_seeds[i]
            for i in range(1, (Prio3.SHARES-1) * 2, 2)
        ]
        k_helper_blinds = [None] * (Prio3.SHARES-1)
        k_leader_blind = None
    (k_prove,), seeds = front(1, seeds)

    # Finish measurement shares and joint randomness parts.
    inp = Prio3.Flp.encode(measurement)
    leader_meas_share = inp
    k_joint_rand_parts = []
    for j in range(Prio3.SHARES-1):
        helper_meas_share = Prio3.Prg.expand_into_vec(
            Prio3.Flp.Field,
            k_helper_meas_shares[j],
            Prio3.custom(DST_MEASUREMENT_SHARE),
            byte(j+1),
            Prio3.Flp.INPUT_LEN
        )
        leader_meas_share = vec_sub(leader_meas_share,
                                    helper_meas_share)
        if use_joint_rand:
            encoded = Prio3.Flp.Field.encode_vec(helper_meas_share)
            k_joint_rand_part = Prio3.Prg.derive_seed(
                k_helper_blinds[j],
                Prio3.custom(DST_JOINT_RAND_PART),
                byte(j+1) + nonce + encoded,
            )
            k_joint_rand_parts.append(k_joint_rand_part)

    # Finish joint randomness.
    if use_joint_rand:
        encoded = Prio3.Flp.Field.encode_vec(leader_meas_share)
        k_joint_rand_part = Prio3.Prg.derive_seed(
            k_leader_blind,
            Prio3.custom(DST_JOINT_RAND_PART),
            byte(0) + nonce + encoded,
        )
        k_joint_rand_parts.insert(0, k_joint_rand_part)
        joint_rand = Prio3.Prg.expand_into_vec(
            Prio3.Flp.Field,
            Prio3.joint_rand(k_joint_rand_parts),
            Prio3.custom(DST_JOINT_RANDOMNESS),
            b'',
            Prio3.Flp.JOINT_RAND_LEN,
        )
    else:
        joint_rand = []

    # Finish the proof shares.
    prove_rand = Prio3.Prg.expand_into_vec(
        Prio3.Flp.Field,
        k_prove,
        Prio3.custom(DST_PROVE_RANDOMNESS),
        b'',
        Prio3.Flp.PROVE_RAND_LEN,
    )
    proof = Prio3.Flp.prove(inp, prove_rand, joint_rand)
    leader_proof_share = proof
    for j in range(Prio3.SHARES-1):
        helper_proof_share = Prio3.Prg.expand_into_vec(
            Prio3.Flp.Field,
            k_helper_proof_shares[j],
            Prio3.custom(DST_PROOF_SHARE),
            byte(j+1),
            Prio3.Flp.PROOF_LEN,
        )
        leader_proof_share = vec_sub(leader_proof_share,
                                     helper_proof_share)

    # Each Aggregator's input share contains its measurement share,
    # proof share, and blind. The public share contains the
    # Aggregators' joint randomness parts.
    input_shares = []
    input_shares.append(Prio3.encode_leader_share(
        leader_meas_share,
        leader_proof_share,
        k_leader_blind,
    ))
    for j in range(Prio3.SHARES-1):
        input_shares.append(Prio3.encode_helper_share(
            k_helper_meas_shares[j],
            k_helper_proof_shares[j],
            k_helper_blinds[j],
        ))
    public_share = Prio3.encode_public_share(k_joint_rand_parts)
    return (public_share, input_shares)
</pre>
</div>
<figcaption><a href="#figure-13" class="selfRef">Figure 13</a>:
<a href="#name-input-distribution-algorith" class="selfRef">Input-distribution algorithm for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="preparation">
<section id="section-7.2.2">
          <h4 id="name-preparation-3">
<a href="#section-7.2.2" class="section-number selfRef">7.2.2. </a><a href="#name-preparation-3" class="section-name selfRef">Preparation</a>
          </h4>
<p id="section-7.2.2-1">This section describes the process of recovering output shares from the input
shares. The high-level idea is that each Aggregator first queries its input and
proof share locally, then exchanges its verifier share with the other
Aggregators. The verifier shares are then combined into the verifier message,
which is used to decide whether to accept.<a href="#section-7.2.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2.2-2">In addition, the Aggregators must ensure that they have all used the same joint
randomness for the query-generation algorithm. The joint randomness is generated
by a PRG seed. Each Aggregator derives a "part" of this seed from its input
share and the "blind" generated by the client. The seed is derived by hashing
together the parts, so before running the query-generation algorithm, it must
first gather the parts derived by the other Aggregators.<a href="#section-7.2.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2.2-3">In order to avoid extra round of communication, the Client sends each Aggregator
a "hint" consisting of the other Aggregators' parts of the joint randomness
seed. This leaves open the possibility that the Client cheated by, say, forcing
the Aggregators to use joint randomness that biases the proof check procedure
some way in its favor. To mitigate this, the Aggregators also check that they
have all computed the same joint randomness seed before accepting their output
shares. To do so, they exchange their parts of the joint randomness along with
their verifier shares.<a href="#section-7.2.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2.2-4">The definitions of constants and a few auxiliary functions are defined in
<a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>.<a href="#section-7.2.2-4" class="pilcrow">¶</a></p>
<span id="name-preparation-state-for-prio3"></span><div id="prio3-prep-state">
<figure id="figure-14">
            <div class="alignLeft art-text artwork" id="section-7.2.2-5.1">
<pre>
def prep_init(Prio3, verify_key, agg_id, _agg_param,
              nonce, public_share, input_share):
    k_joint_rand_parts = Prio3.decode_public_share(public_share)
    (meas_share, proof_share, k_blind) = \
        Prio3.decode_leader_share(input_share) if agg_id == 0 else \
        Prio3.decode_helper_share(agg_id, input_share)
    out_share = Prio3.Flp.truncate(meas_share)

    # Compute joint randomness.
    joint_rand = []
    k_corrected_joint_rand, k_joint_rand_part = None, None
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        encoded = Prio3.Flp.Field.encode_vec(meas_share)
        k_joint_rand_part = Prio3.Prg.derive_seed(k_blind,
            Prio3.custom(DST_JOINT_RAND_PART),
            byte(agg_id) + nonce + encoded)
        k_joint_rand_parts[agg_id] = k_joint_rand_part
        k_corrected_joint_rand = Prio3.joint_rand(k_joint_rand_parts)
        joint_rand = Prio3.Prg.expand_into_vec(
            Prio3.Flp.Field,
            k_corrected_joint_rand,
            Prio3.custom(DST_JOINT_RANDOMNESS),
            b'',
            Prio3.Flp.JOINT_RAND_LEN,
        )

    # Query the measurement and proof share.
    query_rand = Prio3.Prg.expand_into_vec(
        Prio3.Flp.Field,
        verify_key,
        Prio3.custom(DST_QUERY_RANDOMNESS),
        nonce,
        Prio3.Flp.QUERY_RAND_LEN,
    )
    verifier_share = Prio3.Flp.query(meas_share,
                                     proof_share,
                                     query_rand,
                                     joint_rand,
                                     Prio3.SHARES)

    prep_msg = Prio3.encode_prep_share(verifier_share,
                                       k_joint_rand_part)
    return (out_share, k_corrected_joint_rand, prep_msg)

def prep_next(Prio3, prep, inbound):
    (out_share, k_corrected_joint_rand, prep_msg) = prep

    if inbound is None:
        return (prep, prep_msg)

    k_joint_rand_check = Prio3.decode_prep_msg(inbound)
    if k_joint_rand_check != k_corrected_joint_rand:
        raise ERR_VERIFY # joint randomness check failed

    return out_share

def prep_shares_to_prep(Prio3, _agg_param, prep_shares):
    verifier = Prio3.Flp.Field.zeros(Prio3.Flp.VERIFIER_LEN)
    k_joint_rand_parts = []
    for encoded in prep_shares:
        (verifier_share, k_joint_rand_part) = \
            Prio3.decode_prep_share(encoded)

        verifier = vec_add(verifier, verifier_share)

        if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
            k_joint_rand_parts.append(k_joint_rand_part)

    if not Prio3.Flp.decide(verifier):
        raise ERR_VERIFY # proof verifier check failed

    k_joint_rand_check = None
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        k_joint_rand_check = Prio3.joint_rand(k_joint_rand_parts)
    return Prio3.encode_prep_msg(k_joint_rand_check)
</pre>
</div>
<figcaption><a href="#figure-14" class="selfRef">Figure 14</a>:
<a href="#name-preparation-state-for-prio3" class="selfRef">Preparation state for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="validity-of-aggregation-parameters">
<section id="section-7.2.3">
          <h4 id="name-validity-of-aggregation-param">
<a href="#section-7.2.3" class="section-number selfRef">7.2.3. </a><a href="#name-validity-of-aggregation-param" class="section-name selfRef">Validity of Aggregation Parameters</a>
          </h4>
<p id="section-7.2.3-1">Every input share <span class="bcp14">MUST</span> only be used once, regardless of the aggregation
parameters used.<a href="#section-7.2.3-1" class="pilcrow">¶</a></p>
<span id="name-validity-of-aggregation-parame"></span><div id="prio3-validity-scope">
<figure id="figure-15">
            <div class="alignLeft art-text artwork" id="section-7.2.3-2.1">
<pre>
def is_valid(agg_param, previous_agg_params):
    return len(previous_agg_params) == 0
</pre>
</div>
<figcaption><a href="#figure-15" class="selfRef">Figure 15</a>:
<a href="#name-validity-of-aggregation-parame" class="selfRef">Validity of aggregation parameters for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="aggregation">
<section id="section-7.2.4">
          <h4 id="name-aggregation-3">
<a href="#section-7.2.4" class="section-number selfRef">7.2.4. </a><a href="#name-aggregation-3" class="section-name selfRef">Aggregation</a>
          </h4>
<p id="section-7.2.4-1">Aggregating a set of output shares is simply a matter of adding up the vectors
element-wise.<a href="#section-7.2.4-1" class="pilcrow">¶</a></p>
<span id="name-aggregation-algorithm-for-p"></span><div id="prio3-out2agg">
<figure id="figure-16">
            <div class="alignLeft art-text artwork" id="section-7.2.4-2.1">
<pre>
def out_shares_to_agg_share(Prio3, _agg_param, out_shares):
    agg_share = Prio3.Flp.Field.zeros(Prio3.Flp.OUTPUT_LEN)
    for out_share in out_shares:
        agg_share = vec_add(agg_share, out_share)
    return Prio3.Flp.Field.encode_vec(agg_share)
</pre>
</div>
<figcaption><a href="#figure-16" class="selfRef">Figure 16</a>:
<a href="#name-aggregation-algorithm-for-p" class="selfRef">Aggregation algorithm for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="unsharding">
<section id="section-7.2.5">
          <h4 id="name-unsharding-3">
<a href="#section-7.2.5" class="section-number selfRef">7.2.5. </a><a href="#name-unsharding-3" class="section-name selfRef">Unsharding</a>
          </h4>
<p id="section-7.2.5-1">To unshard a set of aggregate shares, the Collector first adds up the vectors
element-wise. It then converts each element of the vector into an integer.<a href="#section-7.2.5-1" class="pilcrow">¶</a></p>
<span id="name-computation-of-the-aggregat"></span><div id="prio3-agg-output">
<figure id="figure-17">
            <div class="alignLeft art-text artwork" id="section-7.2.5-2.1">
<pre>
def agg_shares_to_result(Prio3, _agg_param,
                         agg_shares, num_measurements):
    agg = Prio3.Flp.Field.zeros(Prio3.Flp.OUTPUT_LEN)
    for agg_share in agg_shares:
        agg = vec_add(agg, Prio3.Flp.Field.decode_vec(agg_share))
    return Prio3.Flp.decode(agg, num_measurements)
</pre>
</div>
<figcaption><a href="#figure-17" class="selfRef">Figure 17</a>:
<a href="#name-computation-of-the-aggregat" class="selfRef">Computation of the aggregate result for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="prio3-auxiliary">
<section id="section-7.2.6">
          <h4 id="name-auxiliary-functions-2">
<a href="#section-7.2.6" class="section-number selfRef">7.2.6. </a><a href="#name-auxiliary-functions-2" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<div class="alignLeft art-text artwork" id="section-7.2.6-1">
<pre>
def joint_rand(Prio3, k_joint_rand_parts):
    return Prio3.Prg.derive_seed(
        zeros(Prio3.Prg.SEED_SIZE),
        Prio3.custom(DST_JOINT_RAND_SEED),
        concat(k_joint_rand_parts),
    )
</pre><a href="#section-7.2.6-1" class="pilcrow">¶</a>
</div>
<div id="message-serialization">
<section id="section-7.2.6.1">
            <h5 id="name-message-serialization">
<a href="#section-7.2.6.1" class="section-number selfRef">7.2.6.1. </a><a href="#name-message-serialization" class="section-name selfRef">Message Serialization</a>
            </h5>
<div class="alignLeft art-text artwork" id="section-7.2.6.1-1">
<pre>
def encode_leader_share(Prio3,
                        meas_share,
                        proof_share,
                        k_blind):
    encoded = Bytes()
    encoded += Prio3.Flp.Field.encode_vec(meas_share)
    encoded += Prio3.Flp.Field.encode_vec(proof_share)
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        encoded += k_blind
    return encoded

def decode_leader_share(Prio3, encoded):
    l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.INPUT_LEN
    encoded_meas_share, encoded = encoded[:l], encoded[l:]
    meas_share = Prio3.Flp.Field.decode_vec(encoded_meas_share)
    l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.PROOF_LEN
    encoded_proof_share, encoded = encoded[:l], encoded[l:]
    proof_share = Prio3.Flp.Field.decode_vec(encoded_proof_share)
    l = Prio3.Prg.SEED_SIZE
    if Prio3.Flp.JOINT_RAND_LEN == 0:
        if len(encoded) != 0:
            raise ERR_DECODE
        return (meas_share, proof_share, None)
    k_blind, encoded = encoded[:l], encoded[l:]
    if len(encoded) != 0:
        raise ERR_DECODE
    return (meas_share, proof_share, k_blind)

def encode_helper_share(Prio3,
                        k_meas_share,
                        k_proof_share,
                        k_blind):
    encoded = Bytes()
    encoded += k_meas_share
    encoded += k_proof_share
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        encoded += k_blind
    return encoded

def decode_helper_share(Prio3, agg_id, encoded):
    c_meas_share = Prio3.custom(DST_MEASUREMENT_SHARE)
    c_proof_share = Prio3.custom(DST_PROOF_SHARE)
    l = Prio3.Prg.SEED_SIZE
    k_meas_share, encoded = encoded[:l], encoded[l:]
    meas_share = Prio3.Prg.expand_into_vec(Prio3.Flp.Field,
                                           k_meas_share,
                                           c_meas_share,
                                           byte(agg_id),
                                           Prio3.Flp.INPUT_LEN)
    k_proof_share, encoded = encoded[:l], encoded[l:]
    proof_share = Prio3.Prg.expand_into_vec(Prio3.Flp.Field,
                                            k_proof_share,
                                            c_proof_share,
                                            byte(agg_id),
                                            Prio3.Flp.PROOF_LEN)
    if Prio3.Flp.JOINT_RAND_LEN == 0:
        if len(encoded) != 0:
            raise ERR_DECODE
        return (meas_share, proof_share, None)
    k_blind, encoded = encoded[:l], encoded[l:]
    if len(encoded) != 0:
        raise ERR_DECODE
    return (meas_share, proof_share, k_blind)

def encode_public_share(Prio3,
                        k_joint_rand_parts):
    encoded = Bytes()
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        encoded += concat(k_joint_rand_parts)
    return encoded

def decode_public_share(Prio3, encoded):
    l = Prio3.Prg.SEED_SIZE
    if Prio3.Flp.JOINT_RAND_LEN == 0:
        if len(encoded) != 0:
            raise ERR_DECODE
        return None
    k_joint_rand_parts = []
    for i in range(Prio3.SHARES):
        k_joint_rand_part, encoded = encoded[:l], encoded[l:]
        k_joint_rand_parts.append(k_joint_rand_part)
    if len(encoded) != 0:
        raise ERR_DECODE
    return k_joint_rand_parts

def encode_prep_share(Prio3, verifier, k_joint_rand):
    encoded = Bytes()
    encoded += Prio3.Flp.Field.encode_vec(verifier)
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        encoded += k_joint_rand
    return encoded

def decode_prep_share(Prio3, encoded):
    l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.VERIFIER_LEN
    encoded_verifier, encoded = encoded[:l], encoded[l:]
    verifier = Prio3.Flp.Field.decode_vec(encoded_verifier)
    if Prio3.Flp.JOINT_RAND_LEN == 0:
        if len(encoded) != 0:
            raise ERR_DECODE
        return (verifier, None)
    l = Prio3.Prg.SEED_SIZE
    k_joint_rand, encoded = encoded[:l], encoded[l:]
    if len(encoded) != 0:
        raise ERR_DECODE
    return (verifier, k_joint_rand)

def encode_prep_msg(Prio3, k_joint_rand_check):
    encoded = Bytes()
    if Prio3.Flp.JOINT_RAND_LEN &gt; 0:
        encoded += k_joint_rand_check
    return encoded

def decode_prep_msg(Prio3, encoded):
    if Prio3.Flp.JOINT_RAND_LEN == 0:
        if len(encoded) != 0:
            raise ERR_DECODE
        return None
    l = Prio3.Prg.SEED_SIZE
    k_joint_rand_check, encoded = encoded[:l], encoded[l:]
    if len(encoded) != 0:
        raise ERR_DECODE
    return k_joint_rand_check
</pre><a href="#section-7.2.6.1-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="flp-generic">
<section id="section-7.3">
        <h3 id="name-a-general-purpose-flp">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-a-general-purpose-flp" class="section-name selfRef">A General-Purpose FLP</a>
        </h3>
<p id="section-7.3-1">This section describes an FLP based on the construction from in <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>,
Section 4.2. We begin in <a href="#flp-generic-overview" class="auto internal xref">Section 7.3.1</a> with an overview of their proof
system and the extensions to their proof system made here. The construction is
specified in <a href="#flp-generic-construction" class="auto internal xref">Section 7.3.3</a>.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-7.3-2.1">
            <p id="section-7.3-2.1.1">OPEN ISSUE We're not yet sure if specifying this general-purpose FLP is
desirable. It might be preferable to specify specialized FLPs for each data
type that we want to standardize, for two reasons. First, clear and concise
specifications are likely easier to write for specialized FLPs rather than the
general one. Second, we may end up tailoring each FLP to the measurement type
in a way that improves performance, but breaks compatibility with the
general-purpose FLP.<a href="#section-7.3-2.1.1" class="pilcrow">¶</a></p>
<p id="section-7.3-2.1.2">In any case, we can't make this decision until we know which data types to
standardize, so for now, we'll stick with the general-purpose construction.
The reference implementation can be found at
https://github.com/cfrg/draft-irtf-cfrg-vdaf/tree/main/poc.<a href="#section-7.3-2.1.2" class="pilcrow">¶</a></p>
</li>
        </ul>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-7.3-3.1">
            <p id="section-7.3-3.1.1">OPEN ISSUE Chris Wood points out that the this section reads more like a paper
than a standard. Eventually we'll want to work this into something that is
readily consumable by the CFRG.<a href="#section-7.3-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<div id="flp-generic-overview">
<section id="section-7.3.1">
          <h4 id="name-overview-2">
<a href="#section-7.3.1" class="section-number selfRef">7.3.1. </a><a href="#name-overview-2" class="section-name selfRef">Overview</a>
          </h4>
<p id="section-7.3.1-1">In the proof system of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, validity is defined via an arithmetic
circuit evaluated over the input: If the circuit output is zero, then the input
is deemed valid; otherwise, if the circuit output is non-zero, then the input is
deemed invalid. Thus the goal of the proof system is merely to allow the
verifier to evaluate the validity circuit over the input. For our application
(<a href="#prio3" class="auto internal xref">Section 7</a>), this computation is distributed among multiple Aggregators, each of
which has only a share of the input.<a href="#section-7.3.1-1" class="pilcrow">¶</a></p>
<p id="section-7.3.1-2">Suppose for a moment that the validity circuit <code>C</code> is affine, meaning its only
operations are addition and multiplication-by-constant. In particular, suppose
the circuit does not contain a multiplication gate whose operands are both
non-constant. Then to decide if an input <code>x</code> is valid, each Aggregator could
evaluate <code>C</code> on its share of <code>x</code> locally, broadcast the output share to its
peers, then combine the output shares locally to recover <code>C(x)</code>. This is true
because for any <code>SHARES</code>-way secret sharing of <code>x</code> it holds that<a href="#section-7.3.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-3">
<pre>
C(x_shares[0] + ... + x_shares[SHARES-1]) =
    C(x_shares[0]) + ... + C(x_shares[SHARES-1])
</pre><a href="#section-7.3.1-3" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-4">(Note that, for this equality to hold, it may be necessary to scale any
constants in the circuit by <code>SHARES</code>.) However this is not the case if <code>C</code> is
not-affine (i.e., it contains at least one multiplication gate whose operands
are non-constant). In the proof system of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, the proof is designed to
allow the (distributed) verifier to compute the non-affine operations using only
linear operations on (its share of) the input and proof.<a href="#section-7.3.1-4" class="pilcrow">¶</a></p>
<p id="section-7.3.1-5">To make this work, the proof system is restricted to validity circuits that
exhibit a special structure. Specifically, an arithmetic circuit with "G-gates"
(see <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Definition 5.2) is composed of affine gates and any number of
instances of a distinguished gate <code>G</code>, which may be non-affine. We will refer to
this class of circuits as 'gadget circuits' and to <code>G</code> as the "gadget".<a href="#section-7.3.1-5" class="pilcrow">¶</a></p>
<p id="section-7.3.1-6">As an illustrative example, consider a validity circuit <code>C</code> that recognizes the
set <code>L = set([0], [1])</code>. That is, <code>C</code> takes as input a length-1 vector <code>x</code> and
returns 0 if <code>x[0]</code> is in <code>[0,2)</code> and outputs something else otherwise. This
circuit can be expressed as the following degree-2 polynomial:<a href="#section-7.3.1-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-7">
<pre>
C(x) = (x[0] - 1) * x[0] = x[0]^2 - x[0]
</pre><a href="#section-7.3.1-7" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-8">This polynomial recognizes <code>L</code> because <code>x[0]^2 = x[0]</code> is only true if <code>x[0] ==
0</code> or <code>x[0] == 1</code>. Notice that the polynomial involves a non-affine operation,
<code>x[0]^2</code>. In order to apply <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Theorem 4.3, the circuit needs to be
rewritten in terms of a gadget that subsumes this non-affine operation. For
example, the gadget might be multiplication:<a href="#section-7.3.1-8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-9">
<pre>
Mul(left, right) = left * right
</pre><a href="#section-7.3.1-9" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-10">The validity circuit can then be rewritten in terms of <code>Mul</code> like so:<a href="#section-7.3.1-10" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-11">
<pre>
C(x[0]) = Mul(x[0], x[0]) - x[0]
</pre><a href="#section-7.3.1-11" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-12">The proof system of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> allows the verifier to evaluate each instance
of the gadget (i.e., <code>Mul(x[0], x[0])</code> in our example) using a linear function
of the input and proof. The proof is constructed roughly as follows. Let <code>C</code> be
the validity circuit and suppose the gadget is arity-<code>L</code> (i.e., it has <code>L</code> input
wires.). Let <code>wire[j-1,k-1]</code> denote the value of the <code>j</code>th wire of the <code>k</code>th
call to the gadget during the evaluation of <code>C(x)</code>. Suppose there are <code>M</code> such
calls and fix distinct field elements <code>alpha[0], ..., alpha[M-1]</code>. (We will
require these points to have a special property, as we'll discuss in
<a href="#flp-generic-overview-extensions" class="auto internal xref">Section 7.3.1.1</a>; but for the moment it is only important
that they are distinct.)<a href="#section-7.3.1-12" class="pilcrow">¶</a></p>
<p id="section-7.3.1-13">The prover constructs from <code>wire</code> and <code>alpha</code> a polynomial that, when evaluated
at <code>alpha[k-1]</code>, produces the output of the <code>k</code>th call to the gadget. Let us
call this the "gadget polynomial". Polynomial evaluation is linear, which means
that, in the distributed setting, the Client can disseminate additive shares of
the gadget polynomial that the Aggregators then use to compute additive shares
of each gadget output, allowing each Aggregator to compute its share of <code>C(x)</code>
locally.<a href="#section-7.3.1-13" class="pilcrow">¶</a></p>
<p id="section-7.3.1-14">There is one more wrinkle, however: It is still possible for a malicious prover
to produce a gadget polynomial that would result in <code>C(x)</code> being computed
incorrectly, potentially resulting in an invalid input being accepted. To
prevent this, the verifier performs a probabilistic test to check that the
gadget polynomial is well-formed. This test, and the procedure for constructing
the gadget polynomial, are described in detail in <a href="#flp-generic-construction" class="auto internal xref">Section 7.3.3</a>.<a href="#section-7.3.1-14" class="pilcrow">¶</a></p>
<div id="flp-generic-overview-extensions">
<section id="section-7.3.1.1">
            <h5 id="name-extensions">
<a href="#section-7.3.1.1" class="section-number selfRef">7.3.1.1. </a><a href="#name-extensions" class="section-name selfRef">Extensions</a>
            </h5>
<p id="section-7.3.1.1-1">The FLP described in the next section extends the proof system <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>,
Section 4.2 in three ways.<a href="#section-7.3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-2">First, the validity circuit in our construction includes an additional, random
input (this is the "joint randomness" derived from the input shares in Prio3;
see <a href="#prio3-construction" class="auto internal xref">Section 7.2</a>). This allows for circuit optimizations that trade a
small soundness error for a shorter proof. For example, consider a circuit that
recognizes the set of length-<code>N</code> vectors for which each element is either one or
zero. A deterministic circuit could be constructed for this language, but it
would involve a large number of multiplications that would result in a large
proof. (See the discussion in <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Section 5.2 for details). A much
shorter proof can be constructed for the following randomized circuit:<a href="#section-7.3.1.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1.1-3">
<pre>
C(inp, r) = r * Range2(inp[0]) + ... + r^N * Range2(inp[N-1])
</pre><a href="#section-7.3.1.1-3" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1.1-4">(Note that this is a special case of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Theorem 5.2.) Here <code>inp</code> is
the length-<code>N</code> input and <code>r</code> is a random field element. The gadget circuit
<code>Range2</code> is the "range-check" polynomial described above, i.e., <code>Range2(x) = x^2 -
x</code>. The idea is that, if <code>inp</code> is valid (i.e., each <code>inp[j]</code> is in <code>[0,2)</code>),
then the circuit will evaluate to 0 regardless of the value of <code>r</code>; but if
<code>inp[j]</code> is not in <code>[0,2)</code> for some <code>j</code>, the output will be non-zero with high
probability.<a href="#section-7.3.1.1-4" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-5">The second extension implemented by our FLP allows the validity circuit to
contain multiple gadget types. (This generalization was suggested in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Remark 4.5.) For example, the following circuit is allowed, where
<code>Mul</code> and <code>Range2</code> are the gadgets defined above (the input has length <code>N+1</code>):<a href="#section-7.3.1.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1.1-6">
<pre>
C(inp, r) = r * Range2(inp[0]) + ... + r^N * Range2(inp[N-1]) + \
            2^0 * inp[0]       + ... + 2^(N-1) * inp[N-1]     - \
            Mul(inp[N], inp[N])
</pre><a href="#section-7.3.1.1-6" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1.1-7">Finally, <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Theorem 4.3 makes no restrictions on the choice of the
fixed points <code>alpha[0], ..., alpha[M-1]</code>, other than to require that the points
are distinct. In this document, the fixed points are chosen so that the gadget
polynomial can be constructed efficiently using the Cooley-Tukey FFT ("Fast
Fourier Transform") algorithm. Note that this requires the field to be
"FFT-friendly" as defined in <a href="#field-fft-friendly" class="auto internal xref">Section 6.1.2</a>.<a href="#section-7.3.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="flp-generic-valid">
<section id="section-7.3.2">
          <h4 id="name-validity-circuits">
<a href="#section-7.3.2" class="section-number selfRef">7.3.2. </a><a href="#name-validity-circuits" class="section-name selfRef">Validity Circuits</a>
          </h4>
<p id="section-7.3.2-1">The FLP described in <a href="#flp-generic-construction" class="auto internal xref">Section 7.3.3</a> is defined in terms of a
validity circuit <code>Valid</code> that implements the interface described here.<a href="#section-7.3.2-1" class="pilcrow">¶</a></p>
<p id="section-7.3.2-2">A concrete <code>Valid</code> defines the following parameters:<a href="#section-7.3.2-2" class="pilcrow">¶</a></p>
<span id="name-validity-circuit-parameters"></span><table class="center" id="table-7">
            <caption>
<a href="#table-7" class="selfRef">Table 7</a>:
<a href="#name-validity-circuit-parameters" class="selfRef">Validity circuit parameters.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">A list of gadgets</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Number of times each gadget is called</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>INPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the input</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the aggregatable output</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the random input</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">The type of measurement</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">An FFT-friendly finite field as defined in <a href="#field-fft-friendly" class="auto internal xref">Section 6.1.2</a>
</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.3.2-4">Each gadget <code>G</code> in <code>GADGETS</code> defines a constant <code>DEGREE</code> that specifies the
circuit's "arithmetic degree". This is defined to be the degree of the
polynomial that computes it. For example, the <code>Mul</code> circuit in
<a href="#flp-generic-overview" class="auto internal xref">Section 7.3.1</a> is defined by the polynomial <code>Mul(x) = x * x</code>, which
has degree <code>2</code>. Hence, the arithmetic degree of this gadget is <code>2</code>.<a href="#section-7.3.2-4" class="pilcrow">¶</a></p>
<p id="section-7.3.2-5">Each gadget also defines a parameter <code>ARITY</code> that specifies the circuit's arity
(i.e., the number of input wires).<a href="#section-7.3.2-5" class="pilcrow">¶</a></p>
<p id="section-7.3.2-6">A concrete <code>Valid</code> provides the following methods for encoding a measurement as
an input vector, truncating an input vector to the length of an aggregatable
output, and converting an aggregated output to an aggregate result:<a href="#section-7.3.2-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-7.1">
              <p id="section-7.3.2-7.1.1"><code>Valid.encode(measurement: Measurement) -&gt; Vec[Field]</code> returns a vector of
length <code>INPUT_LEN</code> representing a measurement.<a href="#section-7.3.2-7.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-7.2">
              <p id="section-7.3.2-7.2.1"><code>Valid.truncate(input: Vec[Field]) -&gt; Vec[Field]</code> returns a vector of length
<code>OUTPUT_LEN</code> representing an aggregatable output.<a href="#section-7.3.2-7.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-7.3">
              <p id="section-7.3.2-7.3.1"><code>Valid.decode(output: Vec[Field], num_measurements: Unsigned) -&gt; AggResult</code>
returns an aggregate result.<a href="#section-7.3.2-7.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.2-8">Finally, the following class methods are derived for each concrete <code>Valid</code>:<a href="#section-7.3.2-8" class="pilcrow">¶</a></p>
<span id="name-derived-methods-for-validit"></span><figure id="figure-18">
            <div class="alignLeft art-text artwork" id="section-7.3.2-9.1">
<pre>
# Length of the prover randomness.
def prove_rand_len(Valid):
    return sum(map(lambda g: g.ARITY, Valid.GADGETS))

# Length of the query randomness.
def query_rand_len(Valid):
    return len(Valid.GADGETS)

# Length of the proof.
def proof_len(Valid):
    length = 0
    for (g, g_calls) in zip(Valid.GADGETS, Valid.GADGET_CALLS):
        P = next_power_of_2(1 + g_calls)
        length += g.ARITY + g.DEGREE * (P - 1) + 1
    return length

# Length of the verifier message.
def verifier_len(Valid):
    length = 1
    for g in Valid.GADGETS:
        length += g.ARITY + 1
    return length
</pre>
</div>
<figcaption><a href="#figure-18" class="selfRef">Figure 18</a>:
<a href="#name-derived-methods-for-validit" class="selfRef">Derived methods for validity circuits.</a>
            </figcaption></figure>
</section>
</div>
<div id="flp-generic-construction">
<section id="section-7.3.3">
          <h4 id="name-construction-2">
<a href="#section-7.3.3" class="section-number selfRef">7.3.3. </a><a href="#name-construction-2" class="section-name selfRef">Construction</a>
          </h4>
<p id="section-7.3.3-1">This section specifies <code>FlpGeneric</code>, an implementation of the <code>Flp</code> interface
(<a href="#flp" class="auto internal xref">Section 7.1</a>). It has as a generic parameter a validity circuit <code>Valid</code> implementing
the interface defined in <a href="#flp-generic-valid" class="auto internal xref">Section 7.3.2</a>.<a href="#section-7.3.3-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-7.3.3-2.1">
              <p id="section-7.3.3-2.1.1">NOTE A reference implementation can be found in
https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/flp_generic.sage.<a href="#section-7.3.3-2.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.3-3">The FLP parameters for <code>FlpGeneric</code> are defined in <a href="#flp-generic-param" class="auto internal xref">Table 8</a>. The
required methods for generating the proof, generating the verifier, and deciding
validity are specified in the remaining subsections.<a href="#section-7.3.3-3" class="pilcrow">¶</a></p>
<p id="section-7.3.3-4">In the remainder, we let <code>[n]</code> denote the set <code>{1, ..., n}</code> for positive integer
<code>n</code>. We also define the following constants:<a href="#section-7.3.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3-5.1">
              <p id="section-7.3.3-5.1.1">Let <code>H = len(Valid.GADGETS)</code><a href="#section-7.3.3-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.3-5.2">
              <p id="section-7.3.3-5.2.1">For each <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3-5.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3-5.2.2.1">
                  <p id="section-7.3.3-5.2.2.1.1">Let <code>G_i = Valid.GADGETS[i]</code><a href="#section-7.3.3-5.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-5.2.2.2">
                  <p id="section-7.3.3-5.2.2.2.1">Let <code>L_i = Valid.GADGETS[i].ARITY</code><a href="#section-7.3.3-5.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-5.2.2.3">
                  <p id="section-7.3.3-5.2.2.3.1">Let <code>M_i = Valid.GADGET_CALLS[i]</code><a href="#section-7.3.3-5.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-5.2.2.4">
                  <p id="section-7.3.3-5.2.2.4.1">Let <code>P_i = next_power_of_2(M_i+1)</code><a href="#section-7.3.3-5.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-5.2.2.5">
                  <p id="section-7.3.3-5.2.2.5.1">Let <code>alpha_i = Field.gen()^(Field.GEN_ORDER / P_i)</code><a href="#section-7.3.3-5.2.2.5.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<span id="name-flp-parameters-of-flpgeneri"></span><div id="flp-generic-param">
<table class="center" id="table-8">
            <caption>
<a href="#table-8" class="selfRef">Table 8</a>:
<a href="#name-flp-parameters-of-flpgeneri" class="selfRef">FLP Parameters of FlpGeneric.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROVE_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.prove_rand_len()</code> (see <a href="#flp-generic-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>QUERY_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.query_rand_len()</code> (see <a href="#flp-generic-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.JOINT_RAND_LEN</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>INPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.INPUT_LEN</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.OUTPUT_LEN</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOF_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.proof_len()</code> (see <a href="#flp-generic-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>VERIFIER_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.verifier_len()</code> (see <a href="#flp-generic-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.Measurement</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid.Field</code>
</td>
              </tr>
            </tbody>
          </table>
</div>
<div id="flp-generic-construction-prove">
<section id="section-7.3.3.1">
            <h5 id="name-proof-generation">
<a href="#section-7.3.3.1" class="section-number selfRef">7.3.3.1. </a><a href="#name-proof-generation" class="section-name selfRef">Proof Generation</a>
            </h5>
<p id="section-7.3.3.1-1">On input <code>inp</code>, <code>prove_rand</code>, and <code>joint_rand</code>, the proof is computed as
follows:<a href="#section-7.3.3.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.3.1-2">
<li id="section-7.3.3.1-2.1">
                <p id="section-7.3.3.1-2.1.1">For each <code>i</code> in <code>[H]</code> create an empty table <code>wire_i</code>.<a href="#section-7.3.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.1-2.2">
                <p id="section-7.3.3.1-2.2.1">Partition the prover randomness <code>prove_rand</code> into sub-vectors <code>seed_1, ...,
seed_H</code> where <code>len(seed_i) == L_i</code> for all <code>i</code> in <code>[H]</code>. Let us call these
the "wire seeds" of each gadget.<a href="#section-7.3.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.1-2.3">
                <p id="section-7.3.3.1-2.3.1">Evaluate <code>Valid</code> on input of <code>inp</code> and <code>joint_rand</code>, recording the inputs of
each gadget in the corresponding table. Specifically, for every <code>i</code> in <code>[H]</code>,
set <code>wire_i[j-1,k-1]</code> to the value on the <code>j</code>th wire into the <code>k</code>th call to
gadget <code>G_i</code>.<a href="#section-7.3.3.1-2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.1-2.4">
                <p id="section-7.3.3.1-2.4.1">Compute the "wire polynomials". That is, for every <code>i</code> in <code>[H]</code> and <code>j</code> in
<code>[L_i]</code>, construct <code>poly_wire_i[j-1]</code>, the <code>j</code>th wire polynomial for the
<code>i</code>th gadget, as follows:<a href="#section-7.3.3.1-2.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.1-2.4.2.1">
                    <p id="section-7.3.3.1-2.4.2.1.1">Let <code>w = [seed_i[j-1], wire_i[j-1,0], ..., wire_i[j-1,M_i-1]]</code>.<a href="#section-7.3.3.1-2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.1-2.4.2.2">
                    <p id="section-7.3.3.1-2.4.2.2.1">Let <code>padded_w = w + Field.zeros(P_i - len(w))</code>.<a href="#section-7.3.3.1-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                </ul>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-7.3.3.1-2.4.3.1">
                    <p id="section-7.3.3.1-2.4.3.1.1">NOTE We pad <code>w</code> to the nearest power of 2 so that we can use FFT for
interpolating the wire polynomials. Perhaps there is some clever math for
picking <code>wire_inp</code> in a way that avoids having to pad.<a href="#section-7.3.3.1-2.4.3.1.1" class="pilcrow">¶</a></p>
</li>
                </ul>
<ul class="normal">
<li class="normal" id="section-7.3.3.1-2.4.4.1">
                    <p id="section-7.3.3.1-2.4.4.1.1">Let <code>poly_wire_i[j-1]</code> be the lowest degree polynomial for which
<code>poly_wire_i[j-1](alpha_i^k) == padded_w[k]</code> for all <code>k</code> in <code>[P_i]</code>.<a href="#section-7.3.3.1-2.4.4.1.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li id="section-7.3.3.1-2.5">
                <p id="section-7.3.3.1-2.5.1">Compute the "gadget polynomials". That is, for every <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3.1-2.5.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.1-2.5.2.1">
                    <p id="section-7.3.3.1-2.5.2.1.1">Let <code>poly_gadget_i = G_i(poly_wire_i[0], ..., poly_wire_i[L_i-1])</code>. That
is, evaluate the circuit <code>G_i</code> on the wire polynomials for the <code>i</code>th
gadget. (Arithmetic is in the ring of polynomials over <code>Field</code>.)<a href="#section-7.3.3.1-2.5.2.1.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
            </ol>
<p id="section-7.3.3.1-3">The proof is the vector <code>proof = seed_1 + coeff_1 + ... + seed_H + coeff_H</code>,
where <code>coeff_i</code> is the vector of coefficients of <code>poly_gadget_i</code> for each <code>i</code> in
<code>[H]</code>.<a href="#section-7.3.3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="flp-generic-construction-query">
<section id="section-7.3.3.2">
            <h5 id="name-query-generation">
<a href="#section-7.3.3.2" class="section-number selfRef">7.3.3.2. </a><a href="#name-query-generation" class="section-name selfRef">Query Generation</a>
            </h5>
<p id="section-7.3.3.2-1">On input of <code>inp</code>, <code>proof</code>, <code>query_rand</code>, and <code>joint_rand</code>, the verifier message
is generated as follows:<a href="#section-7.3.3.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.3.2-2">
<li id="section-7.3.3.2-2.1">
                <p id="section-7.3.3.2-2.1.1">For every <code>i</code> in <code>[H]</code> create an empty table <code>wire_i</code>.<a href="#section-7.3.3.2-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-2.2">
                <p id="section-7.3.3.2-2.2.1">Partition <code>proof</code> into the sub-vectors <code>seed_1</code>, <code>coeff_1</code>, ..., <code>seed_H</code>,
<code>coeff_H</code> defined in <a href="#flp-generic-construction-prove" class="auto internal xref">Section 7.3.3.1</a>.<a href="#section-7.3.3.2-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-2.3">
                <p id="section-7.3.3.2-2.3.1">Evaluate <code>Valid</code> on input of <code>inp</code> and <code>joint_rand</code>, recording the inputs of
each gadget in the corresponding table. This step is similar to the prover's
step (3.) except the verifier does not evaluate the gadgets. Instead, it
computes the output of the <code>k</code>th call to <code>G_i</code> by evaluating
<code>poly_gadget_i(alpha_i^k)</code>. Let <code>v</code> denote the output of the circuit
evaluation.<a href="#section-7.3.3.2-2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-2.4">
                <p id="section-7.3.3.2-2.4.1">Compute the wire polynomials just as in the prover's step (4.).<a href="#section-7.3.3.2-2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-2.5">
                <p id="section-7.3.3.2-2.5.1">Compute the tests for well-formedness of the gadget polynomials. That is, for
every <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3.2-2.5.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.2-2.5.2.1">
                    <p id="section-7.3.3.2-2.5.2.1.1">Let <code>t = query_rand[i]</code>. Check if <code>t^(P_i) == 1</code>: If so, then raise
ERR_ABORT and halt. (This prevents the verifier from inadvertently leaking
a gadget output in the verifier message.)<a href="#section-7.3.3.2-2.5.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.2-2.5.2.2">
                    <p id="section-7.3.3.2-2.5.2.2.1">Let <code>y_i = poly_gadget_i(t)</code>.<a href="#section-7.3.3.2-2.5.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.2-2.5.2.3">
                    <p id="section-7.3.3.2-2.5.2.3.1">For each <code>j</code> in <code>[0,L_i)</code> let <code>x_i[j-1] = poly_wire_i[j-1](t)</code>.<a href="#section-7.3.3.2-2.5.2.3.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
            </ol>
<p id="section-7.3.3.2-3">The verifier message is the vector <code>verifier = [v] + x_1 + [y_1] + ... + x_H +
[y_H]</code>.<a href="#section-7.3.3.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="decision">
<section id="section-7.3.3.3">
            <h5 id="name-decision">
<a href="#section-7.3.3.3" class="section-number selfRef">7.3.3.3. </a><a href="#name-decision" class="section-name selfRef">Decision</a>
            </h5>
<p id="section-7.3.3.3-1">On input of vector <code>verifier</code>, the verifier decides if the input is valid as
follows:<a href="#section-7.3.3.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.3.3-2">
<li id="section-7.3.3.3-2.1">
                <p id="section-7.3.3.3-2.1.1">Parse <code>verifier</code> into <code>v</code>, <code>x_1</code>, <code>y_1</code>, ..., <code>x_H</code>, <code>y_H</code> as defined in
<a href="#flp-generic-construction-query" class="auto internal xref">Section 7.3.3.2</a>.<a href="#section-7.3.3.3-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.3-2.2">
                <p id="section-7.3.3.3-2.2.1">Check for well-formedness of the gadget polynomials. For every <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3.3-2.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.3-2.2.2.1">
                    <p id="section-7.3.3.3-2.2.2.1.1">Let <code>z = G_i(x_i)</code>. That is, evaluate the circuit <code>G_i</code> on <code>x_i</code> and set
<code>z</code> to the output.<a href="#section-7.3.3.3-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.3-2.2.2.2">
                    <p id="section-7.3.3.3-2.2.2.2.1">If <code>z != y_i</code>, then return <code>False</code> and halt.<a href="#section-7.3.3.3-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li id="section-7.3.3.3-2.3">
                <p id="section-7.3.3.3-2.3.1">Return <code>True</code> if <code>v == 0</code> and <code>False</code> otherwise.<a href="#section-7.3.3.3-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
<div id="encoding">
<section id="section-7.3.3.4">
            <h5 id="name-encoding">
<a href="#section-7.3.3.4" class="section-number selfRef">7.3.3.4. </a><a href="#name-encoding" class="section-name selfRef">Encoding</a>
            </h5>
<p id="section-7.3.3.4-1">The FLP encoding and truncation methods invoke <code>Valid.encode</code>,
<code>Valid.truncate</code>, and <code>Valid.decode</code> in the natural way.<a href="#section-7.3.3.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="prio3-instantiations">
<section id="section-7.4">
        <h3 id="name-instantiations">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-instantiations" class="section-name selfRef">Instantiations</a>
        </h3>
<p id="section-7.4-1">This section specifies instantiations of Prio3 for various measurement types.
Each uses <code>FlpGeneric</code> as the FLP (<a href="#flp-generic" class="auto internal xref">Section 7.3</a>) and is determined by a
validity circuit (<a href="#flp-generic-valid" class="auto internal xref">Section 7.3.2</a>) and a PRG (<a href="#prg" class="auto internal xref">Section 6.2</a>). Test vectors for
each can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-7.4-2.1">
            <p id="section-7.4-2.1.1">NOTE Reference implementations of each of these VDAFs can be found in
https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/vdaf_prio3.sage.<a href="#section-7.4-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<div id="prio3count">
<section id="section-7.4.1">
          <h4 id="name-prio3count">
<a href="#section-7.4.1" class="section-number selfRef">7.4.1. </a><a href="#name-prio3count" class="section-name selfRef">Prio3Count</a>
          </h4>
<p id="section-7.4.1-1">Our first instance of Prio3 is for a simple counter: Each measurement is either
one or zero and the aggregate result is the sum of the measurements.<a href="#section-7.4.1-1" class="pilcrow">¶</a></p>
<p id="section-7.4.1-2">This instance uses PrgSha3 (<a href="#prg-sha3" class="auto internal xref">Section 6.2.1</a>) as its PRG. Its validity
circuit, denoted <code>Count</code>, uses <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>) as its finite field. Its
gadget, denoted <code>Mul</code>, is the degree-2, arity-2 gadget defined as<a href="#section-7.4.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.1-3">
<pre>
def Mul(x, y):
    return x * y
</pre><a href="#section-7.4.1-3" class="pilcrow">¶</a>
</div>
<p id="section-7.4.1-4">The validity circuit is defined as<a href="#section-7.4.1-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.1-5">
<pre>
def Count(inp: Vec[Field64]):
    return Mul(inp[0], inp[0]) - inp[0]
</pre><a href="#section-7.4.1-5" class="pilcrow">¶</a>
</div>
<p id="section-7.4.1-6">The measurement is encoded and decoded as a singleton vector in the natural
way. The parameters for this circuit are summarized below.<a href="#section-7.4.1-6" class="pilcrow">¶</a></p>
<span id="name-parameters-of-validity-circ"></span><table class="center" id="table-9">
            <caption>
<a href="#table-9" class="selfRef">Table 9</a>:
<a href="#name-parameters-of-validity-circ" class="selfRef">Parameters of validity circuit Count.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[Mul]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[1]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>INPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>0</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Unsigned</code>, in range <code>[0,2)</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Unsigned</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
<div id="prio3sum">
<section id="section-7.4.2">
          <h4 id="name-prio3sum">
<a href="#section-7.4.2" class="section-number selfRef">7.4.2. </a><a href="#name-prio3sum" class="section-name selfRef">Prio3Sum</a>
          </h4>
<p id="section-7.4.2-1">The next instance of Prio3 supports summing of integers in a pre-determined
range. Each measurement is an integer in range <code>[0, 2^bits)</code>, where <code>bits</code> is an
associated parameter.<a href="#section-7.4.2-1" class="pilcrow">¶</a></p>
<p id="section-7.4.2-2">This instance of Prio3 uses PrgSha3 (<a href="#prg-sha3" class="auto internal xref">Section 6.2.1</a>) as its PRG. Its validity
circuit, denoted <code>Sum</code>, uses <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>) as its finite field. The
measurement is encoded as a length-<code>bits</code> vector of field elements, where the
<code>l</code>th element of the vector represents the <code>l</code>th bit of the summand:<a href="#section-7.4.2-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.2-3">
<pre>
def encode(Sum, measurement: Integer):
    if 0 &gt; measurement or measurement &gt;= 2^Sum.INPUT_LEN:
        raise ERR_INPUT

    encoded = []
    for l in range(Sum.INPUT_LEN):
        encoded.append(Sum.Field((measurement &gt;&gt; l) &amp; 1))
    return encoded

def truncate(Sum, inp):
    decoded = Sum.Field(0)
    for (l, b) in enumerate(inp):
        w = Sum.Field(1 &lt;&lt; l)
        decoded += w * b
    return [decoded]

def decode(Sum, output, _num_measurements):
    return output[0].as_unsigned()
</pre><a href="#section-7.4.2-3" class="pilcrow">¶</a>
</div>
<p id="section-7.4.2-4">The validity circuit checks that the input consists of ones and zeros. Its
gadget, denoted <code>Range2</code>, is the degree-2, arity-1 gadget defined as<a href="#section-7.4.2-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.2-5">
<pre>
def Range2(x):
    return x^2 - x
</pre><a href="#section-7.4.2-5" class="pilcrow">¶</a>
</div>
<p id="section-7.4.2-6">The validity circuit is defined as<a href="#section-7.4.2-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.2-7">
<pre>
def Sum(inp: Vec[Field128], joint_rand: Vec[Field128]):
    out = Field128(0)
    r = joint_rand[0]
    for x in inp:
        out += r * Range2(x)
        r *= joint_rand[0]
    return out
</pre><a href="#section-7.4.2-7" class="pilcrow">¶</a>
</div>
<span id="name-parameters-of-validity-circu"></span><table class="center" id="table-10">
            <caption>
<a href="#table-10" class="selfRef">Table 10</a>:
<a href="#name-parameters-of-validity-circu" class="selfRef">Parameters of validity circuit Sum.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[Range2]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[bits]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>INPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>bits</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Unsigned</code>, in range <code>[0, 2^bits)</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Unsigned</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
<div id="prio3histogram">
<section id="section-7.4.3">
          <h4 id="name-prio3histogram">
<a href="#section-7.4.3" class="section-number selfRef">7.4.3. </a><a href="#name-prio3histogram" class="section-name selfRef">Prio3Histogram</a>
          </h4>
<p id="section-7.4.3-1">This instance of Prio3 allows for estimating the distribution of the
measurements by computing a simple histogram. Each measurement is an arbitrary
integer and the aggregate result counts the number of measurements that fall in
a set of fixed buckets.<a href="#section-7.4.3-1" class="pilcrow">¶</a></p>
<p id="section-7.4.3-2">This instance of Prio3 uses PrgSha3 (<a href="#prg-sha3" class="auto internal xref">Section 6.2.1</a>) as its PRG. Its validity
circuit, denoted <code>Histogram</code>, uses <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>) as its finite
field. The measurement is encoded as a one-hot vector representing the bucket
into which the measurement falls (let <code>bucket</code> denote a sequence of
monotonically increasing integers):<a href="#section-7.4.3-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.3-3">
<pre>
def encode(Histogram, measurement: Integer):
    boundaries = buckets + [Infinity]
    encoded = [Field128(0) for _ in range(len(boundaries))]
    for i in range(len(boundaries)):
        if measurement &lt;= boundaries[i]:
            encoded[i] = Field128(1)
            return encoded

def truncate(Histogram, inp: Vec[Field128]):
    return inp

def decode(Histogram, output: Vec[Field128], _num_measurements):
    return [bucket_count.as_unsigned() for bucket_count in output]
</pre><a href="#section-7.4.3-3" class="pilcrow">¶</a>
</div>
<p id="section-7.4.3-4">The validity circuit uses <code>Range2</code> (see <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>) as its single gadget. It
checks for one-hotness in two steps, as follows:<a href="#section-7.4.3-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.4.3-5">
<pre>
def Histogram(inp: Vec[Field128],
              joint_rand: Vec[Field128],
              num_shares: Unsigned):
    # Check that each bucket is one or zero.
    range_check = Field128(0)
    r = joint_rand[0]
    for x in inp:
        range_check += r * Range2(x)
        r *= joint_rand[0]

    # Check that the buckets sum to 1.
    sum_check = -Field128(1) * Field128(num_shares).inv()
    for b in inp:
        sum_check += b

    out = joint_rand[1]   * range_check + \
          joint_rand[1]^2 * sum_check
    return out
</pre><a href="#section-7.4.3-5" class="pilcrow">¶</a>
</div>
<p id="section-7.4.3-6">Note that this circuit depends on the number of shares into which the input is
sharded. This is provided to the FLP by Prio3.<a href="#section-7.4.3-6" class="pilcrow">¶</a></p>
<span id="name-parameters-of-validity-circui"></span><table class="center" id="table-11">
            <caption>
<a href="#table-11" class="selfRef">Table 11</a>:
<a href="#name-parameters-of-validity-circui" class="selfRef">Parameters of validity circuit Histogram.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[Range2]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[buckets + 1]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>INPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>buckets + 1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>buckets + 1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>2</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Integer</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Vec[Unsigned]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="poplar1">
<section id="section-8">
      <h2 id="name-poplar1">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-poplar1" class="section-name selfRef">Poplar1</a>
      </h2>
<p id="section-8-1">This section specifies Poplar1, a VDAF for the following task. Each Client holds
a string of length <code>BITS</code> and the Aggregators hold a set of <code>l</code>-bit strings,
where <code>l &lt;= BITS</code>. We will refer to the latter as the set of "candidate
prefixes". The Aggregators' goal is to count how many inputs are prefixed by
each candidate prefix.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">This functionality is the core component of the Poplar protocol <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>,
which was designed to compute the heavy hitters over a set of input strings. At
a high level, the protocol works as follows.<a href="#section-8-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-8-3">
<li id="section-8-3.1">
          <p id="section-8-3.1.1">Each Client splits its input string into input shares and sends one share to
each Aggregator.<a href="#section-8-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.2">
          <p id="section-8-3.2.1">The Aggregators agree on an initial set of candidate prefixes, say <code>0</code> and
<code>1</code>.<a href="#section-8-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.3">
          <p id="section-8-3.3.1">The Aggregators evaluate the VDAF on each set of input shares and aggregate
the recovered output shares. The aggregation parameter is the set of
candidate prefixes.<a href="#section-8-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.4">
          <p id="section-8-3.4.1">The Aggregators send their aggregate shares to the Collector, who combines
them to recover the counts of each candidate prefix.<a href="#section-8-3.4.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.5">
          <p id="section-8-3.5.1">Let <code>H</code> denote the set of prefixes that occurred at least <code>t</code> times. If the
prefixes all have length <code>BITS</code>, then <code>H</code> is the set of <code>t</code>-heavy-hitters.
Otherwise compute the next set of candidate prefixes, e.g., for each <code>p</code> in
<code>H</code>, add <code>p || 0</code> and <code>p || 1</code> to the set. Repeat step 3 with the new set of
candidate prefixes.<a href="#section-8-3.5.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-8-4">Poplar1 is constructed from an "Incremental Distributed Point Function (IDPF)",
a primitive described by <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> that generalizes the notion of a
Distributed Point Function (DPF) <span>[<a href="#GI14" class="cite xref">GI14</a>]</span>. Briefly, a DPF is used to distribute
the computation of a "point function", a function that evaluates to zero on
every input except at a programmable "point". The computation is distributed in
such a way that no one party knows either the point or what it evaluates to.<a href="#section-8-4" class="pilcrow">¶</a></p>
<p id="section-8-5">An IDPF generalizes this "point" to a path on a full binary tree from the root
to one of the leaves. It is evaluated on an "index" representing a unique node
of the tree. If the node is on the programmed path, then the function evaluates
to a non-zero value; otherwise it evaluates to zero. This structure allows an
IDPF to provide the functionality required for the above protocol: To compute
the hit count for an index, just evaluate each set of IDPF shares at that index
and add up the results.<a href="#section-8-5" class="pilcrow">¶</a></p>
<p id="section-8-6">Consider the sub-tree constructed from a set of input strings and a target
threshold <code>t</code> by including all indices that prefix at least <code>t</code> of the input
strings. We shall refer to this structure as the "prefix tree" for the batch of
inputs and target threshold. To compute the <code>t</code>-heavy hitters for a set of
inputs, the Aggregators and Collector first compute the prefix tree, then
extract the heavy hitters from the leaves of this tree. (Note that the prefix
tree may leak more information about the set than the heavy hitters themselves;
see <a href="#agg-param-privacy" class="auto internal xref">Section 9.4</a> for details.)<a href="#section-8-6" class="pilcrow">¶</a></p>
<p id="section-8-7">Poplar1 composes an IDPF with the "secure sketching" protocol of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>.
This protocol ensures that evaluating a set of input shares on a unique set of
candidate prefixes results in shares of a "one-hot" vector, i.e., a vector that
is zero everywhere except for one element, which is equal to one.<a href="#section-8-7" class="pilcrow">¶</a></p>
<p id="section-8-8">The remainder of this section is structured as follows. IDPFs are defined in
<a href="#idpf" class="auto internal xref">Section 8.1</a>; a concrete instantiation is given <a href="#idpf-poplar" class="auto internal xref">Section 8.3</a>. The Poplar1 VDAF is
defined in <a href="#poplar1-construction" class="auto internal xref">Section 8.2</a> in terms of a generic IDPF. Finally, a
concrete instantiation of Poplar1 is specified in <a href="#poplar1-inst" class="auto internal xref">Section 8.4</a>;
test vectors can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-8-8" class="pilcrow">¶</a></p>
<div id="idpf">
<section id="section-8.1">
        <h3 id="name-incremental-distributed-poi">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-incremental-distributed-poi" class="section-name selfRef">Incremental Distributed Point Functions (IDPFs)</a>
        </h3>
<p id="section-8.1-1">An IDPF is defined over a domain of size <code>2^BITS</code>, where <code>BITS</code> is constant
defined by the IDPF. Indexes into the IDPF tree are encoded as integers in range
<code>[0, 2^BITS)</code>. The Client specifies an index <code>alpha</code> and a vector of
values <code>beta</code>, one for each "level" <code>L</code> in range <code>[0, BITS)</code>. The key generation
algorithm generates one IDPF "key" for each Aggregator. When evaluated at level
<code>L</code> and index <code>0 &lt;= prefix &lt; 2^L</code>, each IDPF key returns an additive share of
<code>beta[L]</code> if <code>prefix</code> is the <code>L</code>-bit prefix of <code>alpha</code> and shares of zero
otherwise.<a href="#section-8.1-1" class="pilcrow">¶</a></p>
<p id="section-8.1-2">An index <code>x</code> is defined to be a prefix of another index <code>y</code> as follows. Let
<code>LSB(x, N)</code> denote the least significant <code>N</code> bits of positive integer <code>x</code>. By
definition, a positive integer <code>0 &lt;= x &lt; 2^L</code> is said to be the length-<code>L</code>
prefix of positive integer <code>0 &lt;= y &lt; 2^BITS</code> if <code>LSB(x, L)</code> is equal to the most
significant <code>L</code> bits of <code>LSB(y, BITS)</code>, For example, 6 (110 in binary) is the
length-3 prefix of 25 (11001), but 7 (111) is not.<a href="#section-8.1-2" class="pilcrow">¶</a></p>
<p id="section-8.1-3">Each of the programmed points <code>beta</code> is a vector of elements of some finite
field. We distinguish two types of fields: One for inner nodes (denoted
<code>Idpf.FieldInner</code>), and one for leaf nodes (<code>Idpf.FieldLeaf</code>). (Our
instantiation of Poplar1 (<a href="#poplar1-inst" class="auto internal xref">Section 8.4</a>) will use a much larger field for
leaf nodes than for inner nodes. This is to ensure the IDPF is "extractable" as
defined in <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Definition 1.)<a href="#section-8.1-3" class="pilcrow">¶</a></p>
<p id="section-8.1-4">A concrete IDPF defines the types and constants enumerated in <a href="#idpf-param" class="auto internal xref">Table 12</a>. In
the remainder we write <code>Idpf.Vec</code> as shorthand for the type
<code>Union[Vec[Vec[Idpf.FieldInner]], Vec[Vec[Idpf.FieldLeaf]]]</code>. (This type denotes
either a vector of inner node field elements or leaf node field elements.) The
scheme is comprised of the following algorithms:<a href="#section-8.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-5.1">
            <p id="section-8.1-5.1.1"><code>Idpf.gen(alpha: Unsigned, beta_inner: Vec[Vec[Idpf.FieldInner]], beta_leaf:
Vec[Idpf.FieldLeaf], binder: Bytes, rand: Bytes[Idpf.RAND_SIZE]) -&gt; (Bytes,
Vec[Bytes])</code> is the randomized IDPF-key generation algorithm. (Input <code>rand</code>
consists of the random coins it consumes.) Its inputs are the index <code>alpha</code>
the values <code>beta</code>, and a binder string. The value of <code>alpha</code> <span class="bcp14">MUST</span> be in range
<code>[0, 2^BITS)</code>. The output is a public part that is sent to all Aggregators
and a vector of private IDPF keys, one for each aggregator.<a href="#section-8.1-5.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-8.1-5.2">
            <p id="section-8.1-5.2.1"><code>Idpf.eval(agg_id: Unsigned, public_share: Bytes, key: Bytes, level:
Unsigned, prefixes: Vec[Unsigned], binder: Bytes) -&gt; Idpf.Vec</code> is the
deterministic, stateless IDPF-key evaluation algorithm run by each
Aggregator. Its inputs are the Aggregator's unique identifier, the public
share distributed to all of the Aggregators, the Aggregator's IDPF key, the
"level" at which to evaluate the IDPF, the sequence of candidate prefixes,
and a binder string. It returns the share of the value corresponding to each
candidate prefix.<a href="#section-8.1-5.2.1" class="pilcrow">¶</a></p>
<p id="section-8.1-5.2.2">
The output type depends on the value of <code>level</code>: If <code>level &lt; Idpf.BITS-1</code>, the
output is the value for an inner node, which has type
<code>Vec[Vec[Idpf.FieldInner]]</code>; otherwise, if <code>level == Idpf.BITS-1</code>, then the
output is the value for a leaf node, which has type
<code>Vec[Vec[Idpf.FieldLeaf]]</code>.<a href="#section-8.1-5.2.2" class="pilcrow">¶</a></p>
<p id="section-8.1-5.2.3">
The value of <code>level</code> <span class="bcp14">MUST</span> be in range <code>[0, BITS)</code>. The indexes in <code>prefixes</code>
              <span class="bcp14">MUST</span> all be distinct and in range <code>[0, 2^level)</code>.<a href="#section-8.1-5.2.3" class="pilcrow">¶</a></p>
<p id="section-8.1-5.2.4">
Applications <span class="bcp14">MUST</span> ensure that the Aggregator's identifier is equal to the
integer in range <code>[0, SHARES)</code> that matches the index of <code>key</code> in the sequence
of IDPF keys output by the Client.<a href="#section-8.1-5.2.4" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-8.1-6">In addition, the following method is derived for each concrete <code>Idpf</code>:<a href="#section-8.1-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.1-7">
<pre>
def current_field(Idpf, level):
    return Idpf.FieldInner if level &lt; Idpf.BITS-1 \
                else Idpf.FieldLeaf
</pre><a href="#section-8.1-7" class="pilcrow">¶</a>
</div>
<p id="section-8.1-8">Finally, an implementation note. The interface for IDPFs specified here is
stateless, in the sense that there is no state carried between IDPF evaluations.
This is to align the IDPF syntax with the VDAF abstraction boundary, which does
not include shared state across across VDAF evaluations. In practice, of course,
it will often be beneficial to expose a stateful API for IDPFs and carry the
state across evaluations. See <a href="#idpf-poplar" class="auto internal xref">Section 8.3</a> for details.<a href="#section-8.1-8" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-by"></span><div id="idpf-param">
<table class="center" id="table-12">
          <caption>
<a href="#table-12" class="selfRef">Table 12</a>:
<a href="#name-constants-and-types-defined-by" class="selfRef">Constants and types defined by a concrete IDPF.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">SHARES</td>
              <td class="text-left" rowspan="1" colspan="1">Number of IDPF keys output by IDPF-key generator</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">BITS</td>
              <td class="text-left" rowspan="1" colspan="1">Length in bits of each input string</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">VALUE_LEN</td>
              <td class="text-left" rowspan="1" colspan="1">Number of field elements of each output value</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">RAND_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">Size of the random string consumed by the IDPF-key generator</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">KEY_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">Size in bytes of each IDPF key</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldInner</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation of <code>Field</code> (<a href="#field" class="auto internal xref">Section 6.1</a>) used for values of inner nodes</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldLeaf</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation of <code>Field</code> used for values of leaf nodes</td>
            </tr>
          </tbody>
        </table>
</div>
</section>
</div>
<div id="poplar1-construction">
<section id="section-8.2">
        <h3 id="name-construction-3">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-construction-3" class="section-name selfRef">Construction</a>
        </h3>
<p id="section-8.2-1">This section specifies <code>Poplar1</code>, an implementation of the <code>Vdaf</code> interface
(<a href="#vdaf" class="auto internal xref">Section 5</a>). It is defined in terms of any <code>Idpf</code> (<a href="#idpf" class="auto internal xref">Section 8.1</a>) for which
<code>Idpf.SHARES == 2</code> and <code>Idpf.VALUE_LEN == 2</code> and an implementation of <code>Prg</code>
(<a href="#prg" class="auto internal xref">Section 6.2</a>). The associated constants and types required by the <code>Vdaf</code> interface
are defined in <a href="#poplar1-param" class="auto internal xref">Table 13</a>. The methods required for sharding,
preparation, aggregation, and unsharding are described in the remaining
subsections. These methods make use of constants defined in <a href="#poplar1-const" class="auto internal xref">Table 14</a>.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
<span id="name-vdaf-parameters-for-poplar1"></span><div id="poplar1-param">
<table class="center" id="table-13">
          <caption>
<a href="#table-13" class="selfRef">Table 13</a>:
<a href="#name-vdaf-parameters-for-poplar1" class="selfRef">VDAF parameters for Poplar1.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFY_KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Prg.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>16</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>ROUNDS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Unsigned</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggParam</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Tuple[Unsigned, Vec[Unsigned], Unsigned, Vec[Unsigned]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Prep</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Tuple[Bytes, Unsigned, Idpf.Vec]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OutShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Idpf.Vec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Vec[Unsigned]</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<span id="name-constants-used-by-poplar1"></span><div id="poplar1-const">
<table class="center" id="table-14">
          <caption>
<a href="#table-14" class="selfRef">Table 14</a>:
<a href="#name-constants-used-by-poplar1" class="selfRef">Constants used by Poplar1.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Variable</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">DST_SHARD_RAND: Unsigned</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">DST_CORR_INNER: Unsigned</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">DST_CORR_LEAF: Unsigned</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">DST_VERIFY_RAND: Unsigned</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="client">
<section id="section-8.2.1">
          <h4 id="name-client">
<a href="#section-8.2.1" class="section-number selfRef">8.2.1. </a><a href="#name-client" class="section-name selfRef">Client</a>
          </h4>
<p id="section-8.2.1-1">The client's input is an IDPF index, denoted <code>alpha</code>. The programmed IDPF values
are pairs of field elements <code>(1, k)</code> where each <code>k</code> is chosen at random. This
random value is used as part of the secure sketching protocol of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>,
Appendix C.4. After evaluating their IDPF key shares on a given sequence of
candidate prefixes, the sketching protocol is used by the Aggregators to verify
that they hold shares of a one-hot vector. In addition, for each level of the
tree, the prover generates random elements <code>a</code>, <code>b</code>, and <code>c</code> and computes<a href="#section-8.2.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.2.1-2">
<pre>
    A = -2*a + k
    B = a^2 + b - k*a + c
</pre><a href="#section-8.2.1-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2.1-3">and sends additive shares of <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code> and <code>B</code> to the Aggregators.
Putting everything together, the sharding algorithm is defined as
follows. Function <code>encode_input_shares</code> is defined in <a href="#poplar1-auxiliary" class="auto internal xref">Section 8.2.6</a>.<a href="#section-8.2.1-3" class="pilcrow">¶</a></p>
<span id="name-the-sharding-algorithm-for-"></span><div id="poplar1-mes2inp">
<figure id="figure-19">
            <div class="alignLeft art-text artwork" id="section-8.2.1-4.1">
<pre>
def measurement_to_input_shares(Poplar1, measurement, nonce, rand):
    l = Poplar1.Prg.SEED_SIZE

    # Split the coins into coins for IDPF key generation,
    # correlated randomness, and sharding.
    if len(rand) != Poplar1.RAND_SIZE:
        raise ERR_INPUT # unexpected length for random coins
    idpf_rand, rand = front(Poplar1.Idpf.RAND_SIZE, rand)
    seeds = [rand[i:i+l] for i in range(0,3*l,l)]
    corr_seed, seeds = front(2, seeds)
    (k_shard,), seeds = front(1, seeds)

    prg = Poplar1.Prg(k_shard,
                      Poplar1.custom(DST_SHARD_RAND), b'')

    # Construct the IDPF values for each level of the IDPF tree.
    # Each "data" value is 1; in addition, the Client generates
    # a random "authenticator" value used by the Aggregators to
    # compute the sketch during preparation. This sketch is used
    # to verify the one-hotness of their output shares.
    beta_inner = [
        [Poplar1.Idpf.FieldInner(1), k] \
            for k in prg.next_vec(Poplar1.Idpf.FieldInner,
                                  Poplar1.Idpf.BITS - 1) ]
    beta_leaf = [Poplar1.Idpf.FieldLeaf(1)] + \
        prg.next_vec(Poplar1.Idpf.FieldLeaf, 1)

    # Generate the IDPF keys.
    (public_share, keys) = Poplar1.Idpf.gen(measurement,
                                            beta_inner,
                                            beta_leaf,
                                            idpf_rand)

    # Generate correlated randomness used by the Aggregators to
    # compute a sketch over their output shares. PRG seeds are
    # used to encode shares of the `(a, b, c)` triples.
    # (See [BBCGGI21, Appendix C.4].)
    corr_offsets = vec_add(
        Poplar1.Prg.expand_into_vec(
            Poplar1.Idpf.FieldInner,
            corr_seed[0],
            Poplar1.custom(DST_CORR_INNER),
            byte(0) + nonce,
            3 * (Poplar1.Idpf.BITS-1),
        ),
        Poplar1.Prg.expand_into_vec(
            Poplar1.Idpf.FieldInner,
            corr_seed[1],
            Poplar1.custom(DST_CORR_INNER),
            byte(1) + nonce,
            3 * (Poplar1.Idpf.BITS-1),
        ),
    )
    corr_offsets += vec_add(
        Poplar1.Prg.expand_into_vec(
            Poplar1.Idpf.FieldLeaf,
            corr_seed[0],
            Poplar1.custom(DST_CORR_LEAF),
            byte(0) + nonce,
            3,
        ),
        Poplar1.Prg.expand_into_vec(
            Poplar1.Idpf.FieldLeaf,
            corr_seed[1],
            Poplar1.custom(DST_CORR_LEAF),
            byte(1) + nonce,
            3,
        ),
    )

    # For each level of the IDPF tree, shares of the `(A, B)`
    # pairs are computed from the corresponding `(a, b, c)`
    # triple and authenticator value `k`.
    corr_inner = [[], []]
    for level in range(Poplar1.Idpf.BITS):
        Field = Poplar1.Idpf.current_field(level)
        k = beta_inner[level][1] if level &lt; Poplar1.Idpf.BITS - 1 \
            else beta_leaf[1]
        (a, b, c), corr_offsets = corr_offsets[:3], corr_offsets[3:]
        A = -Field(2) * a + k
        B = a^2 + b - a * k + c
        corr1 = prg.next_vec(Field, 2)
        corr0 = vec_sub([A, B], corr1)
        if level &lt; Poplar1.Idpf.BITS - 1:
            corr_inner[0] += corr0
            corr_inner[1] += corr1
        else:
            corr_leaf = [corr0, corr1]

    # Each input share consists of the Aggregator's IDPF key
    # and a share of the correlated randomness.
    return (public_share,
            Poplar1.encode_input_shares(
                keys, corr_seed, corr_inner, corr_leaf))
</pre>
</div>
<figcaption><a href="#figure-19" class="selfRef">Figure 19</a>:
<a href="#name-the-sharding-algorithm-for-" class="selfRef">The sharding algorithm for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="preparation-1">
<section id="section-8.2.2">
          <h4 id="name-preparation-4">
<a href="#section-8.2.2" class="section-number selfRef">8.2.2. </a><a href="#name-preparation-4" class="section-name selfRef">Preparation</a>
          </h4>
<p id="section-8.2.2-1">The aggregation parameter encodes a sequence of candidate prefixes. When an
Aggregator receives an input share from the Client, it begins by evaluating its
IDPF share on each candidate prefix, recovering a <code>data_share</code> and <code>auth_share</code>
for each. The Aggregators use these and the correlation shares provided by the
Client to verify that the sequence of <code>data_share</code> values are additive shares of
a one-hot vector.<a href="#section-8.2.2-1" class="pilcrow">¶</a></p>
<p id="section-8.2.2-2">Aggregators <span class="bcp14">MUST</span> ensure the candidate prefixes are all unique and appear in
lexicographic order. (This is enforced in the definition of <code>prep_init()</code>
below.) Uniqueness is necessary to ensure the refined measurement (i.e., the sum
of the output shares) is in fact a one-hot vector. Otherwise, sketch
verification might fail, causing the Aggregators to erroneously reject a report
that is actually valid. Note that enforcing the order is not strictly necessary,
but this does allow uniqueness to be determined more efficiently.<a href="#section-8.2.2-2" class="pilcrow">¶</a></p>
<p id="section-8.2.2-3">The algorithms below make use of the auxiliary function <code>decode_input_share()</code>
defined in <a href="#poplar1-auxiliary" class="auto internal xref">Section 8.2.6</a>.<a href="#section-8.2.2-3" class="pilcrow">¶</a></p>
<span id="name-preparation-state-for-popla"></span><div id="poplar1-prep-state">
<figure id="figure-20">
            <div class="alignLeft art-text artwork" id="section-8.2.2-4.1">
<pre>
def prep_init(Poplar1, verify_key, agg_id, agg_param,
              nonce, public_share, input_share):
    (level, prefixes, _, _) = agg_param
    (key, corr_seed, corr_inner, corr_leaf) = \
        Poplar1.decode_input_share(input_share)
    Field = Poplar1.Idpf.current_field(level)

    # Ensure that candidate prefixes are all unique and appear in
    # lexicographic order.
    for i in range(1,len(prefixes)):
        if prefixes[i-1] &gt;= prefixes[i]:
            raise ERR_INPUT # out-of-order prefix

    # Evaluate the IDPF key at the given set of prefixes.
    value = Poplar1.Idpf.eval(
        agg_id, public_share, key, level, prefixes)

    # Get shares of the correlated randomness for computing the
    # Aggregator's share of the sketch for the given level of the IDPF
    # tree.
    if level &lt; Poplar1.Idpf.BITS - 1:
        corr_prg = Poplar1.Prg(corr_seed,
                                    Poplar1.custom(DST_CORR_INNER),
                                    byte(agg_id) + nonce)
        # Fast-forward the PRG state to the current level.
        corr_prg.next_vec(Field, 3 * level)
    else:
        corr_prg = Poplar1.Prg(corr_seed,
                                    Poplar1.custom(DST_CORR_LEAF),
                                    byte(agg_id) + nonce)
    (a_share, b_share, c_share) = corr_prg.next_vec(Field, 3)
    (A_share, B_share) = corr_inner[2*level:2*(level+1)] \
        if level &lt; Poplar1.Idpf.BITS - 1 else corr_leaf

    # Compute the Aggregator's first round of the sketch. These are
    # called the "masked input values" [BBCGGI21, Appendix C.4].
    verify_rand_prg = Poplar1.Prg(verify_key,
        Poplar1.custom(DST_VERIFY_RAND),
        nonce + to_be_bytes(level, 2))
    verify_rand = verify_rand_prg.next_vec(Field, len(prefixes))
    sketch_share = [a_share, b_share, c_share]
    out_share = []
    for (i, r) in enumerate(verify_rand):
        (data_share, auth_share) = value[i]
        sketch_share[0] += data_share * r
        sketch_share[1] += data_share * r^2
        sketch_share[2] += auth_share * r
        out_share.append(data_share)

    prep_mem = sketch_share \
                + [A_share, B_share, Field(agg_id)] \
                + out_share
    return (b'ready', level, prep_mem)

def prep_next(Poplar1, prep_state, opt_sketch):
    (step, level, prep_mem) = prep_state
    Field = Poplar1.Idpf.current_field(level)

    # Aggregators exchange masked input values (step (3.)
    # of [BBCGGI21, Appendix C.4]).
    if step == b'ready' and opt_sketch == None:
        sketch_share, prep_mem = prep_mem[:3], prep_mem[3:]
        return ((b'sketch round 1', level, prep_mem),
                Field.encode_vec(sketch_share))

    # Aggregators exchange evaluated shares (step (4.)).
    elif step == b'sketch round 1' and opt_sketch != None:
        prev_sketch = Field.decode_vec(opt_sketch)
        if len(prev_sketch) == 0:
            prev_sketch = Field.zeros(3)
        elif len(prev_sketch) != 3:
            raise ERR_INPUT # prep message malformed
        (A_share, B_share, agg_id), prep_mem = \
            prep_mem[:3], prep_mem[3:]
        sketch_share = [
            agg_id * (prev_sketch[0]^2 \
                        - prev_sketch[1]
                        - prev_sketch[2]) \
                + A_share * prev_sketch[0] \
                + B_share
        ]
        return ((b'sketch round 2', level, prep_mem),
                Field.encode_vec(sketch_share))

    elif step == b'sketch round 2' and opt_sketch != None:
        if len(opt_sketch) == 0:
            return prep_mem # Output shares
        else:
            raise ERR_INPUT # prep message malformed

    raise ERR_INPUT # unexpected input

def prep_shares_to_prep(Poplar1, agg_param, prep_shares):
    if len(prep_shares) != 2:
        raise ERR_INPUT # unexpected number of prep shares
    (level, _, _, _) = agg_param
    Field = Poplar1.Idpf.current_field(level)
    sketch = vec_add(Field.decode_vec(prep_shares[0]),
                     Field.decode_vec(prep_shares[1]))
    if len(sketch) == 3:
        return Field.encode_vec(sketch)
    elif len(sketch) == 1:
        if sketch == Field.zeros(1):
            # In order to reduce communication overhead, let the
            # empty string denote a successful sketch verification.
            return b''
        else:
            raise ERR_VERIFY # sketch verification failed
    else:
        return ERR_INPUT # unexpected input length
</pre>
</div>
<figcaption><a href="#figure-20" class="selfRef">Figure 20</a>:
<a href="#name-preparation-state-for-popla" class="selfRef">Preparation state for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="validity-of-aggregation-parameters-1">
<section id="section-8.2.3">
          <h4 id="name-validity-of-aggregation-paramet">
<a href="#section-8.2.3" class="section-number selfRef">8.2.3. </a><a href="#name-validity-of-aggregation-paramet" class="section-name selfRef">Validity of Aggregation Parameters</a>
          </h4>
<p id="section-8.2.3-1">Aggregation parameters are valid for a given input share if no aggregation
parameter with the same level has been used with the same input share before.
The whole preparation phase <span class="bcp14">MUST NOT</span> be run more than once for a given
combination of input share and level.<a href="#section-8.2.3-1" class="pilcrow">¶</a></p>
<span id="name-validity-of-aggregation-paramete"></span><div id="poplar1-validity-scope">
<figure id="figure-21">
            <div class="alignLeft art-text artwork" id="section-8.2.3-2.1">
<pre>
def is_valid(agg_param, previous_agg_params):
    # Exit early if this is the first time.
    if len(previous_agg_params) &lt; 1:
      return True

    (level, prefixes, threshold, prefix_counts) = agg_param
    (last_level, last_prefixes, last_threshold, last_prefix_counts) = previous_agg_params[-1]

    # Check that prefix_count for prefixes are above threshold.
    for count in prefix_counts:
      if count &lt; threshold:
        return False

    # Check that level increased by one, and the threshold is the same
    if level != last_level + 1:
      return False
    if threshold != last_threshold:
      return False

    # Check that prefixes are suffixes of the last level's prefixes,
    # and that the counts of siblings sum up to at most the parent's count.
    for i in range(len(prefixes))
      if not parent_index.contains(prefixes[i] &gt;&gt; 1):
        return False
      parent_index = last_prefixes.index(prefixes[i] &gt;&gt; 1)
      count = prefix_counts[i]
      if prefixes[i+1] == prefixes[i] + 1:
        count += prefix_counts[i+1]  # Both children are in this level's prefixes.
      if count &gt; last_prefix_counts[parent_index]:
        return False

    return True
</pre>
</div>
<figcaption><a href="#figure-21" class="selfRef">Figure 21</a>:
<a href="#name-validity-of-aggregation-paramete" class="selfRef">Validity of aggregation parameters for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="aggregation-1">
<section id="section-8.2.4">
          <h4 id="name-aggregation-4">
<a href="#section-8.2.4" class="section-number selfRef">8.2.4. </a><a href="#name-aggregation-4" class="section-name selfRef">Aggregation</a>
          </h4>
<p id="section-8.2.4-1">Aggregation involves simply adding up the output shares.<a href="#section-8.2.4-1" class="pilcrow">¶</a></p>
<span id="name-aggregation-algorithm-for-po"></span><div id="poplar1-out2agg">
<figure id="figure-22">
            <div class="alignLeft art-text artwork" id="section-8.2.4-2.1">
<pre>
def out_shares_to_agg_share(Poplar1, agg_param, out_shares):
    (level, prefixes, _, prefix_counts) = agg_param
    if sum(prefix_counts) &gt; len(out_shares):
      return ERR_VERIFY
    Field = Poplar1.Idpf.current_field(level)
    agg_share = Field.zeros(len(prefixes))
    for out_share in out_shares:
        agg_share = vec_add(agg_share, out_share)
    return Field.encode_vec(agg_share)
</pre>
</div>
<figcaption><a href="#figure-22" class="selfRef">Figure 22</a>:
<a href="#name-aggregation-algorithm-for-po" class="selfRef">Aggregation algorithm for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="unsharding-1">
<section id="section-8.2.5">
          <h4 id="name-unsharding-4">
<a href="#section-8.2.5" class="section-number selfRef">8.2.5. </a><a href="#name-unsharding-4" class="section-name selfRef">Unsharding</a>
          </h4>
<p id="section-8.2.5-1">Finally, the Collector unshards the aggregate result by adding up the aggregate
shares.<a href="#section-8.2.5-1" class="pilcrow">¶</a></p>
<span id="name-computation-of-the-aggregate"></span><div id="poplar1-agg-output">
<figure id="figure-23">
            <div class="alignLeft art-text artwork" id="section-8.2.5-2.1">
<pre>
def agg_shares_to_result(Poplar1, agg_param,
                         agg_shares, _num_measurements):
    (level, prefixes, _, _) = agg_param
    Field = Poplar1.Idpf.current_field(level)
    agg = Field.zeros(len(prefixes))
    for agg_share in agg_shares:
        agg = vec_add(agg, Field.decode_vec(agg_share))
    return list(map(lambda x: x.as_unsigned(), agg))
</pre>
</div>
<figcaption><a href="#figure-23" class="selfRef">Figure 23</a>:
<a href="#name-computation-of-the-aggregate" class="selfRef">Computation of the aggregate result for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="poplar1-auxiliary">
<section id="section-8.2.6">
          <h4 id="name-auxiliary-functions-3">
<a href="#section-8.2.6" class="section-number selfRef">8.2.6. </a><a href="#name-auxiliary-functions-3" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<div id="message-serialization-1">
<section id="section-8.2.6.1">
            <h5 id="name-message-serialization-2">
<a href="#section-8.2.6.1" class="section-number selfRef">8.2.6.1. </a><a href="#name-message-serialization-2" class="section-name selfRef">Message Serialization</a>
            </h5>
<p id="section-8.2.6.1-1">This section defines methods for serializing input shares, as required by the
<code>Vdaf</code> interface. Optional serialization of the aggregation parameter is also
specified below.<a href="#section-8.2.6.1-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6.1-2">Implementation note: The aggregation parameter includes the level of the IDPF
tree and the sequence of indices to evaluate. For implementations that perform
per-report caching across executions of the VDAF, this may be more information
than is strictly needed. In particular, it may be sufficient to convey which
indices from the previous execution will have their children included in the
next. This would help reduce communication overhead.<a href="#section-8.2.6.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.2.6.1-3">
<pre>
def encode_input_shares(Poplar1, keys,
                        corr_seed, corr_inner, corr_leaf):
    input_shares = []
    for (key, seed, inner, leaf) in zip(keys,
                                        corr_seed,
                                        corr_inner,
                                        corr_leaf):
        encoded = Bytes()
        encoded += key
        encoded += seed
        encoded += Poplar1.Idpf.FieldInner.encode_vec(inner)
        encoded += Poplar1.Idpf.FieldLeaf.encode_vec(leaf)
        input_shares.append(encoded)
    return input_shares

def decode_input_share(Poplar1, encoded):
    l = Poplar1.Idpf.KEY_SIZE
    key, encoded = encoded[:l], encoded[l:]
    l = Poplar1.Prg.SEED_SIZE
    corr_seed, encoded = encoded[:l], encoded[l:]
    l = Poplar1.Idpf.FieldInner.ENCODED_SIZE \
        * 2 * (Poplar1.Idpf.BITS - 1)
    encoded_corr_inner, encoded = encoded[:l], encoded[l:]
    corr_inner = Poplar1.Idpf.FieldInner.decode_vec(
        encoded_corr_inner)
    l = Poplar1.Idpf.FieldLeaf.ENCODED_SIZE * 2
    encoded_corr_leaf, encoded = encoded[:l], encoded[l:]
    corr_leaf = Poplar1.Idpf.FieldLeaf.decode_vec(
        encoded_corr_leaf)
    if len(encoded) != 0:
        raise ERR_INPUT
    return (key, corr_seed, corr_inner, corr_leaf)

def encode_agg_param(Poplar1, level, prefixes):
    if level &gt; 2^16 - 1:
        raise ERR_INPUT # level too deep
    if len(prefixes) &gt; 2^32 - 1:
        raise ERR_INPUT # too many prefixes
    encoded = Bytes()
    encoded += to_be_bytes(level, 2)
    encoded += to_be_bytes(len(prefixes), 4)
    packed = 0
    for (i, prefix) in enumerate(prefixes):
        packed |= prefix &lt;&lt; ((level+1) * i)
    l = floor(((level+1) * len(prefixes) + 7) / 8)
    encoded += to_be_bytes(packed, l)
    return encoded

def decode_agg_param(Poplar1, encoded):
    encoded_level, encoded = encoded[:2], encoded[2:]
    level = from_be_bytes(encoded_level)
    encoded_prefix_count, encoded = encoded[:4], encoded[4:]
    prefix_count = from_be_bytes(encoded_prefix_count)
    l = floor(((level+1) * prefix_count + 7) / 8)
    encoded_packed, encoded = encoded[:l], encoded[l:]
    packed = from_be_bytes(encoded_packed)
    prefixes = []
    m = 2^(level+1) - 1
    for i in range(prefix_count):
        prefixes.append(packed &gt;&gt; ((level+1) * i) &amp; m)
    if len(encoded) != 0:
        raise ERR_INPUT
    return (level, prefixes)
</pre><a href="#section-8.2.6.1-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="idpf-poplar">
<section id="section-8.3">
        <h3 id="name-the-idpf-scheme-of">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-the-idpf-scheme-of" class="section-name selfRef">The IDPF scheme of <span class="cite xref">[BBCGGI21]</span></a>
        </h3>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-8.3-1.1">
            <p id="section-8.3-1.1.1">TODO(issue#32) Consider replacing the generic <code>Prg</code> object here with some
fixed-key mode for AES (something along the lines of ia.cr/2019/074). This
would allow us to take advantage of hardware acceleration, which would
significantly improve performance. We use SHA-3 primarily to instantiate
random oracles, but the random oracle model may not be required for IDPF. More
investigation is needed.<a href="#section-8.3-1.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-8.3-2">In this section we specify a concrete IDPF, called IdpfPoplar, suitable for
instantiating Poplar1. The scheme gets its name from the name of the protocol of
<span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>.<a href="#section-8.3-2" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-8.3-3.1">
            <p id="section-8.3-3.1.1">TODO We should consider giving <code>IdpfPoplar</code> a more distinctive name.<a href="#section-8.3-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-8.3-4">The constant and type definitions required by the <code>Idpf</code> interface are given in
<a href="#idpf-poplar-param" class="auto internal xref">Table 15</a>.<a href="#section-8.3-4" class="pilcrow">¶</a></p>
<p id="section-8.3-5">IdpfPoplar requires a PRG for deriving the output shares, as well as a variety
of other artifacts used internally. For performance reasons, we instantiate
this object using PrgFixedKeyAes128 (<a href="#prg-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a>). See
<a href="#prg-vs-ro" class="auto internal xref">Section 9.5</a> for justification of this choice.<a href="#section-8.3-5" class="pilcrow">¶</a></p>
<span id="name-constants-and-type-definiti"></span><div id="idpf-poplar-param">
<table class="center" id="table-15">
          <caption>
<a href="#table-15" class="selfRef">Table 15</a>:
<a href="#name-constants-and-type-definiti" class="selfRef">Constants and type definitions for IdpfPoplar.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">SHARES</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">BITS</td>
              <td class="text-left" rowspan="1" colspan="1">any positive integer</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">VALUE_LEN</td>
              <td class="text-left" rowspan="1" colspan="1">any positive integer</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">KEY_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Prg.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldInner</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldLeaf</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field255</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="key-generation">
<section id="section-8.3.1">
          <h4 id="name-key-generation">
<a href="#section-8.3.1" class="section-number selfRef">8.3.1. </a><a href="#name-key-generation" class="section-name selfRef">Key Generation</a>
          </h4>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-8.3.1-1.1">
              <p id="section-8.3.1-1.1.1">TODO Describe the construction in prose, beginning with a gentle introduction
to the high level idea.<a href="#section-8.3.1-1.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-8.3.1-2">The description of the IDPF-key generation algorithm makes use of auxiliary
functions <code>extend()</code>, <code>convert()</code>, and <code>encode_public_share()</code> defined in
<a href="#idpf-poplar-helper-functions" class="auto internal xref">Section 8.3.3</a>. In the following, we let <code>Field2</code> denote the
field <code>GF(2)</code>.<a href="#section-8.3.1-2" class="pilcrow">¶</a></p>
<span id="name-idpf-key-generation-algorit"></span><div id="idpf-poplar-gen">
<figure id="figure-24">
            <div class="alignLeft art-text artwork" id="section-8.3.1-3.1">
<pre>
def gen(IdpfPoplar, alpha, beta_inner, beta_leaf, binder, rand):
    if alpha &gt;= 2^IdpfPoplar.BITS:
        raise ERR_INPUT # alpha too long
    if len(beta_inner) != IdpfPoplar.BITS - 1:
        raise ERR_INPUT # beta_inner vector is the wrong size
    if len(rand) != IdpfPoplar.RAND_SIZE:
        raise ERR_INPUT # unexpected length for random coins

    init_seed = [
        rand[:PrgFixedKeyAes128.SEED_SIZE],
        rand[PrgFixedKeyAes128.SEED_SIZE:],
    ]

    seed = init_seed.copy()
    ctrl = [Field2(0), Field2(1)]
    correction_words = []
    for level in range(IdpfPoplar.BITS):
        Field = IdpfPoplar.current_field(level)
        keep = (alpha &gt;&gt; (IdpfPoplar.BITS - level - 1)) &amp; 1
        lose = 1 - keep
        bit = Field2(keep)

        (s0, t0) = IdpfPoplar.extend(seed[0], binder)
        (s1, t1) = IdpfPoplar.extend(seed[1], binder)
        seed_cw = xor(s0[lose], s1[lose])
        ctrl_cw = (
            t0[0] + t1[0] + bit + Field2(1),
            t0[1] + t1[1] + bit,
        )

        x0 = xor(s0[keep], ctrl[0].conditional_select(seed_cw))
        x1 = xor(s1[keep], ctrl[1].conditional_select(seed_cw))
        (seed[0], w0) = IdpfPoplar.convert(level, x0, binder)
        (seed[1], w1) = IdpfPoplar.convert(level, x1, binder)
        ctrl[0] = t0[keep] + ctrl[0] * ctrl_cw[keep]
        ctrl[1] = t1[keep] + ctrl[1] * ctrl_cw[keep]

        b = beta_inner[level] if level &lt; IdpfPoplar.BITS-1 \
                else beta_leaf
        if len(b) != IdpfPoplar.VALUE_LEN:
            raise ERR_INPUT # beta too long or too short

        w_cw = vec_add(vec_sub(b, w0), w1)
        # Implementation note: Here we negate the correction word if
        # the control bit `ctrl[1]` is set. We avoid branching on the
        # value in order to reduce leakage via timing side channels.
        mask = Field(1) - Field(2) * Field(ctrl[1].as_unsigned())
        for i in range(len(w_cw)):
            w_cw[i] *= mask

        correction_words.append((seed_cw, ctrl_cw, w_cw))

    public_share = IdpfPoplar.encode_public_share(correction_words)
    return (public_share, init_seed)
</pre>
</div>
<figcaption><a href="#figure-24" class="selfRef">Figure 24</a>:
<a href="#name-idpf-key-generation-algorit" class="selfRef">IDPF-key generation algorithm of IdpfPoplar.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="key-evaluation">
<section id="section-8.3.2">
          <h4 id="name-key-evaluation">
<a href="#section-8.3.2" class="section-number selfRef">8.3.2. </a><a href="#name-key-evaluation" class="section-name selfRef">Key Evaluation</a>
          </h4>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-8.3.2-1.1">
              <p id="section-8.3.2-1.1.1">TODO Describe in prose how IDPF-key evaluation algorithm works.<a href="#section-8.3.2-1.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-8.3.2-2">The description of the IDPF-evaluation algorithm makes use of auxiliary
functions <code>extend()</code>, <code>convert()</code>, and <code>decode_public_share()</code> defined in
<a href="#idpf-poplar-helper-functions" class="auto internal xref">Section 8.3.3</a>.<a href="#section-8.3.2-2" class="pilcrow">¶</a></p>
<span id="name-idpf-evaluation-generation-"></span><div id="idpf-poplar-eval">
<figure id="figure-25">
            <div class="alignLeft art-text artwork" id="section-8.3.2-3.1">
<pre>
def eval(IdpfPoplar, agg_id, public_share, init_seed,
         level, prefixes, binder):
    if agg_id &gt;= IdpfPoplar.SHARES:
        raise ERR_INPUT # invalid aggregator ID
    if level &gt;= IdpfPoplar.BITS:
        raise ERR_INPUT # level too deep
    if len(set(prefixes)) != len(prefixes):
        raise ERR_INPUT # candidate prefixes are non-unique

    correction_words = IdpfPoplar.decode_public_share(public_share)
    out_share = []
    for prefix in prefixes:
        if prefix &gt;= 2^(level+1):
            raise ERR_INPUT # prefix too long

        # The Aggregator's output share is the value of a node of
        # the IDPF tree at the given `level`. The node's value is
        # computed by traversing the path defined by the candidate
        # `prefix`. Each node in the tree is represented by a seed
        # (`seed`) and a set of control bits (`ctrl`).
        seed = init_seed
        ctrl = Field2(agg_id)
        for current_level in range(level+1):
            bit = (prefix &gt;&gt; (level - current_level)) &amp; 1

            # Implementation note: Typically the current round of
            # candidate prefixes would have been derived from
            # aggregate results computed during previous rounds. For
            # example, when using `IdpfPoplar` to compute heavy
            # hitters, a string whose hit count exceeded the given
            # threshold in the last round would be the prefix of each
            # `prefix` in the current round. (See [BBCGGI21,
            # Section 5.1].) In this case, part of the path would
            # have already been traversed.
            #
            # Re-computing nodes along previously traversed paths is
            # wasteful. Implementations can eliminate this added
            # complexity by caching nodes (i.e., `(seed, ctrl)`
            # pairs) output by previous calls to `eval_next()`.
            (seed, ctrl, y) = IdpfPoplar.eval_next(seed, ctrl,
                correction_words[current_level], current_level, bit, binder)
        out_share.append(y if agg_id == 0 else vec_neg(y))
    return out_share

# Compute the next node in the IDPF tree along the path determined by
# a candidate prefix. The next node is determined by `bit`, the bit
# of the prefix corresponding to the next level of the tree.
#
# TODO Consider implementing some version of the optimization
# discussed at the end of [BBCGGI21, Appendix C.2]. This could on
# average reduce the number of AES calls by a constant factor.
def eval_next(IdpfPoplar, prev_seed, prev_ctrl,
              correction_word, level, bit, binder):
    Field = IdpfPoplar.current_field(level)
    (seed_cw, ctrl_cw, w_cw) = correction_word
    (s, t) = IdpfPoplar.extend(prev_seed, binder)
    s[0] = xor(s[0], prev_ctrl.conditional_select(seed_cw))
    s[1] = xor(s[1], prev_ctrl.conditional_select(seed_cw))
    t[0] += ctrl_cw[0] * prev_ctrl
    t[1] += ctrl_cw[1] * prev_ctrl

    next_ctrl = t[bit]
    (next_seed, y) = IdpfPoplar.convert(level, s[bit], binder)
    # Implementation note: Here we add the correction word to the
    # output if `next_ctrl` is set. We avoid branching on the value of
    # the control bit in order to reduce side channel leakage.
    mask = Field(next_ctrl.as_unsigned())
    for i in range(len(y)):
        y[i] += w_cw[i] * mask

    return (next_seed, next_ctrl, y)
</pre>
</div>
<figcaption><a href="#figure-25" class="selfRef">Figure 25</a>:
<a href="#name-idpf-evaluation-generation-" class="selfRef">IDPF-evaluation generation algorithm of IdpfPoplar.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="idpf-poplar-helper-functions">
<section id="section-8.3.3">
          <h4 id="name-auxiliary-functions-4">
<a href="#section-8.3.3" class="section-number selfRef">8.3.3. </a><a href="#name-auxiliary-functions-4" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<span id="name-helper-functions-for-idpfpo"></span><div id="idpf-poplar-helpers">
<figure id="figure-26">
            <div class="alignLeft art-text artwork" id="section-8.3.3-1.1">
<pre>
def extend(IdpfPoplar, seed, binder):
    prg = PrgFixedKeyAes128(seed, format_custom(1, 0, 0), binder)
    s = [
        prg.next(PrgFixedKeyAes128.SEED_SIZE),
        prg.next(PrgFixedKeyAes128.SEED_SIZE),
    ]
    b = prg.next(1)[0]
    t = [Field2(b &amp; 1), Field2((b &gt;&gt; 1) &amp; 1)]
    return (s, t)

def convert(IdpfPoplar, level, seed, binder):
    prg = PrgFixedKeyAes128(seed, format_custom(1, 0, 1), binder)
    next_seed = prg.next(PrgFixedKeyAes128.SEED_SIZE)
    Field = IdpfPoplar.current_field(level)
    w = prg.next_vec(Field, IdpfPoplar.VALUE_LEN)
    return (next_seed, w)

def encode_public_share(IdpfPoplar, correction_words):
    encoded = Bytes()
    control_bits = list(itertools.chain.from_iterable(
        cw[1] for cw in correction_words
    ))
    encoded += pack_bits(control_bits)
    for (level, (seed_cw, _, w_cw)) \
        in enumerate(correction_words):
        Field = IdpfPoplar.current_field(level)
        encoded += seed_cw
        encoded += Field.encode_vec(w_cw)
    return encoded

def decode_public_share(IdpfPoplar, encoded):
    l = floor((2*IdpfPoplar.BITS + 7) / 8)
    encoded_ctrl, encoded = encoded[:l], encoded[l:]
    control_bits = unpack_bits(encoded_ctrl, 2 * IdpfPoplar.BITS)
    correction_words = []
    for level in range(IdpfPoplar.BITS):
        Field = IdpfPoplar.current_field(level)
        ctrl_cw = (
            control_bits[level * 2],
            control_bits[level * 2 + 1],
        )
        l = PrgFixedKeyAes128.SEED_SIZE
        seed_cw, encoded = encoded[:l], encoded[l:]
        l = Field.ENCODED_SIZE * IdpfPoplar.VALUE_LEN
        encoded_w_cw, encoded = encoded[:l], encoded[l:]
        w_cw = Field.decode_vec(encoded_w_cw)
        correction_words.append((seed_cw, ctrl_cw, w_cw))
    if len(encoded) != 0:
        raise ERR_DECODE
    return correction_words
</pre>
</div>
<figcaption><a href="#figure-26" class="selfRef">Figure 26</a>:
<a href="#name-helper-functions-for-idpfpo" class="selfRef">Helper functions for IdpfPoplar.</a>
            </figcaption></figure>
</div>
<p id="section-8.3.3-2">Here, <code>pack_bits()</code> takes a list of bits, packs each group of eight bits into a
byte, in LSB to MSB order, padding the most significant bits of the last byte
with zeros as necessary, and returns the byte array. <code>unpack_bits()</code> performs
the reverse operation: it takes in a byte array and a number of bits, and
returns a list of bits, extracting eight bits from each byte in turn, in LSB to
MSB order, and stopping after the requested number of bits. If the byte array
has an incorrect length, or if unused bits in the last bytes are not zero, it
throws an error.<a href="#section-8.3.3-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="poplar1-inst">
<section id="section-8.4">
        <h3 id="name-instantiation">
<a href="#section-8.4" class="section-number selfRef">8.4. </a><a href="#name-instantiation" class="section-name selfRef">Instantiation</a>
        </h3>
<p id="section-8.4-1">By default, Poplar1 is instantiated with IdpfPoplar (<code>VALUE_LEN == 2</code>) and
PrgSha3 (<a href="#prg-sha3" class="auto internal xref">Section 6.2.1</a>). This VDAF is suitable for any positive value of <code>BITS</code>.
Test vectors can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-8.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="security">
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">VDAFs have two essential security goals:<a href="#section-9-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9-2">
<li id="section-9-2.1">
          <p id="section-9-2.1.1">Privacy: An attacker that controls the network, the Collector, and a subset
of Clients and Aggregators learns nothing about the measurements of honest
Clients beyond what it can deduce from the aggregate result.<a href="#section-9-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-2.2">
          <p id="section-9-2.2.1">Robustness: An attacker that controls the network and a subset of Clients
cannot cause the Collector to compute anything other than the aggregate of
the measurements of honest Clients.<a href="#section-9-2.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-9-3">Formal definitions of privacy and robustness can be found in <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. A VDAF
is the core cryptographic primitive of a protocol that achieves the above
privacy and robustness goals. It is not sufficient on its own, however. The
application will need to assure a few security properties, for example:<a href="#section-9-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.1">
          <p id="section-9-4.1.1">Securely distributing the long-lived parameters, in particular the
verification key.<a href="#section-9-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-9-4.2">
          <p id="section-9-4.2.1">Establishing secure channels:<a href="#section-9-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.2.2.1">
              <p id="section-9-4.2.2.1.1">Confidential and authentic channels among Aggregators, and between the
Aggregators and the Collector; and<a href="#section-9-4.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-4.2.2.2">
              <p id="section-9-4.2.2.2.1">Confidential and Aggregator-authenticated channels between Clients and
Aggregators.<a href="#section-9-4.2.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-9-4.3">
          <p id="section-9-4.3.1">Enforcing the non-collusion properties required of the specific VDAF in use.<a href="#section-9-4.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-9-5">In such an environment, a VDAF provides the high-level privacy property
described above: The Collector learns only the aggregate measurement, and
nothing about individual measurements aside from what can be inferred from the
aggregate result.  The Aggregators learn neither individual measurements nor the
aggregate result.  The Collector is assured that the aggregate statistic
accurately reflects the inputs as long as the Aggregators correctly executed
their role in the VDAF.<a href="#section-9-5" class="pilcrow">¶</a></p>
<p id="section-9-6">On their own, VDAFs do not mitigate Sybil attacks <span>[<a href="#Dou02" class="cite xref">Dou02</a>]</span>. In this attack, the
adversary observes a subset of input shares transmitted by a Client it is
interested in. It allows the input shares to be processed, but corrupts and
picks bogus measurements for the remaining Clients.  Applications can guard
against these risks by adding additional controls on report submission,
such as client authentication and rate limits.<a href="#section-9-6" class="pilcrow">¶</a></p>
<p id="section-9-7">VDAFs do not inherently provide differential privacy <span>[<a href="#Dwo06" class="cite xref">Dwo06</a>]</span>.  The VDAF approach
to private measurement can be viewed as complementary to differential privacy,
relying on non-collusion instead of statistical noise to protect the privacy of
the inputs.  It is possible that a future VDAF could incorporate differential
privacy features, e.g., by injecting noise before the sharding stage and
removing it after unsharding.<a href="#section-9-7" class="pilcrow">¶</a></p>
<div id="requirements-for-the-verification-key">
<section id="section-9.1">
        <h3 id="name-requirements-for-the-verifi">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-requirements-for-the-verifi" class="section-name selfRef">Requirements for the Verification Key</a>
        </h3>
<p id="section-9.1-1">The Aggregators are responsible for exchanging the verification key in advance
of executing the VDAF. Any procedure is acceptable as long as the following
conditions are met:<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9.1-2">
<li id="section-9.1-2.1">
            <p id="section-9.1-2.1.1">To ensure robustness of the computation, the Aggregators <span class="bcp14">MUST NOT</span> reveal the
verification key to the Clients. Otherwise, a malicious Client might be able
to exploit knowledge of this key to craft an invalid report that would be
accepted by the Aggregators.<a href="#section-9.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-9.1-2.2">
            <p id="section-9.1-2.2.1">To ensure privacy of the measurements, the Aggregators <span class="bcp14">MUST</span> commit to the
verification key prior to processing reports generated by Clients. Otherwise,
a malicious Aggregator may be able to craft a verification key that, for a
given report, causes an honest Aggregator to leak information about the
measurement during preparation.<a href="#section-9.1-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-9.1-3">Meeting these conditions is required in order to leverage security analysis in
the framework of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. Their definition of robustness allows the attacker,
playing the role of a cohort of malicious Clients, to submit arbitrary reports
to the Aggregators and eavesdrop on their communications as they process them.
Security in this model is achievable as long as the verification key is kept
secret from the attacker.<a href="#section-9.1-3" class="pilcrow">¶</a></p>
<p id="section-9.1-4">The privacy definition of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span> considers an active attacker that controls
the network and a subset of Aggregators; in addition, the attacker is allowed to
choose the verification key used by each honest Aggregator over the course of
the experiment. Security is achievable in this model as long as the key is
picked at the start of the experiment, prior to any reports being generated.
(The model also requires nonces to be generated at random; see
<a href="#nonce-requirements" class="auto internal xref">Section 9.2</a> below.)<a href="#section-9.1-4" class="pilcrow">¶</a></p>
<p id="section-9.1-5">Meeting these requirements is relatively straightforward. For example, the
Aggregators may designate one of their peers to generate the verification key
and distribute it to the others. To assure Clients of key commitment, the
Clients and (honest) Aggregators could bind reports to a shared context string
derived from the key. For instance, the "task ID" of DAP <span>[<a href="#DAP" class="cite xref">DAP</a>]</span> could be set to
the hash of the verification key; then as long as honest Aggregators only
consume reports for the task indicated by the Client, forging a new key after
the fact would reduce to finding collisions in the underlying hash function.
(Keeping the key secret from the Clients would require the hash function to be
one-way.) However, since rotating the key implies rotating the task ID, this
scheme would not allow key rotation over the lifetime of a task.<a href="#section-9.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="nonce-requirements">
<section id="section-9.2">
        <h3 id="name-requirements-for-the-nonce">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-requirements-for-the-nonce" class="section-name selfRef">Requirements for the Nonce</a>
        </h3>
<p id="section-9.2-1">The sharding and preparation steps of VDAF execution depend on a nonce
associated with the Client's report. To ensure privacy of the underlying
measurement, the Client <span class="bcp14">MUST</span> generate this nonce using a CSPRNG. This is
required in order to leverage security analysis for the privacy definition of
<span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, which assumes the nonce is chosen at random prior to generating the
report.<a href="#section-9.2-1" class="pilcrow">¶</a></p>
<p id="section-9.2-2">Other security considerations may require the nonce to be non-repeating. For
example, to achieve differential privacy it is necessary to avoid "over
exposing" a measurement by including it too many times in a single batch or
across multiple batches. It is <span class="bcp14">RECOMMENDED</span> that the nonce generated by the
Client be used by the Aggregators for replay protection.<a href="#section-9.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="requirements-for-the-aggregation-parameters">
<section id="section-9.3">
        <h3 id="name-requirements-for-the-aggreg">
<a href="#section-9.3" class="section-number selfRef">9.3. </a><a href="#name-requirements-for-the-aggreg" class="section-name selfRef">Requirements for the Aggregation Parameters</a>
        </h3>
<p id="section-9.3-1">As described in <a href="#sec-daf-validity-scopes" class="auto internal xref">Section 4.3</a> and <a href="#sec-vdaf-validity-scopes" class="auto internal xref">Section 5.3</a>
respectively, DAFs and VDAFs may impose restrictions on the re-use of input
shares. This is to ensure that correlated randomness provided by the Client
through the input share is not used more than once, which might compromise
confidentiality of the Client's measurements.<a href="#section-9.3-1" class="pilcrow">¶</a></p>
<p id="section-9.3-2">Protocols that make use of VDAFs therefore <span class="bcp14">MUST</span> call <code>Vdaf.is_valid</code>
on the set of all aggregation parameters used for a Client's input share, and
only proceed with the preparation and aggregation phases if that function call
returns <code>True</code>.<a href="#section-9.3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="agg-param-privacy">
<section id="section-9.4">
        <h3 id="name-additional-privacy-consider">
<a href="#section-9.4" class="section-number selfRef">9.4. </a><a href="#name-additional-privacy-consider" class="section-name selfRef">Additional Privacy Considerations for Aggregation Parameters</a>
        </h3>
<p id="section-9.4-1">Aggregating a batch of reports multiple times, each time with a different
aggregation parameter, could result in information leakage beyond what is used
by the application.<a href="#section-9.4-1" class="pilcrow">¶</a></p>
<p id="section-9.4-2">For example, when Poplar1 is used for heavy hitters, the Aggregators learn not
only the heavy hitters themselves, but also the prefix tree (as defined in
<a href="#poplar1" class="auto internal xref">Section 8</a>) computed along the way. Indeed, this leakage is inherent to any
construction that uses an IDPF (<a href="#idpf" class="auto internal xref">Section 8.1</a>) in the same way. Depending on the
distribution of the measurements, the prefix tree can leak a significant amount
of information about unpopular inputs. For instance, it is possible (though
perhaps unlikely) for a large set of non-heavy-hitter values to share a common
prefix, which would be leaked by a prefix tree with a sufficiently small
threshold.<a href="#section-9.4-2" class="pilcrow">¶</a></p>
<p id="section-9.4-3">The only known, general-purpose approach to mitigating this leakage is via
differential privacy.<a href="#section-9.4-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-9.4-4.1">
            <p id="section-9.4-4.1.1">TODO(issue #94) Describe (or point to some description of) the central DP
mechanism for Poplar described in <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>.<a href="#section-9.4-4.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="prg-vs-ro">
<section id="section-9.5">
        <h3 id="name-pseudorandom-generators-and">
<a href="#section-9.5" class="section-number selfRef">9.5. </a><a href="#name-pseudorandom-generators-and" class="section-name selfRef">Pseudorandom Generators and random oracles</a>
        </h3>
<p id="section-9.5-1">The objects we describe in <a href="#prg" class="auto internal xref">Section 6.2</a> share a common interface, which we have
called Prg. However, these are not necessarily all modeled as cryptographic
Pseudorandom Generators in the security analyses of our protocols. Instead, most
of them are modeled as random oracles. For these use cases, we want to be
conservative in our assumptions, and hence prescribe PrgSha3 as the only
<span class="bcp14">RECOMMENDED</span> Prg instantiation.<a href="#section-9.5-1" class="pilcrow">¶</a></p>
<p id="section-9.5-2">The one exception is the PRG used in the Idpf implementation IdpfPoplar
<a href="#idpf-poplar" class="auto internal xref">Section 8.3</a>. Here, a random oracle is not needed to prove security, and
hence a construction based on fixed-key AES <a href="#prg-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a> can be
used. However, as PrgFixedKeyAes128 has been shown to be differentiable from
a random oracle <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>, it is <span class="bcp14">NOT RECOMMENDED</span> to use it anywhere else.<a href="#section-9.5-2" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-9.5-3.1">
            <p id="section-9.5-3.1.1">OPEN ISSUE: We may want to drop the common interface for PRGs and random
oracles. See issue #159.<a href="#section-9.5-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-10">
      <h2 id="name-iana-considerations">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-10-1">A codepoint for each (V)DAF in this document is defined in the table below. Note
that <code>0xFFFF0000</code> through <code>0xFFFFFFFF</code> are reserved for private use.<a href="#section-10-1" class="pilcrow">¶</a></p>
<span id="name-unique-identifiers-for-vdaf"></span><div id="codepoints">
<table class="center" id="table-16">
        <caption>
<a href="#table-16" class="selfRef">Table 16</a>:
<a href="#name-unique-identifiers-for-vdaf" class="selfRef">Unique identifiers for (V)DAFs.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Value</th>
            <th class="text-left" rowspan="1" colspan="1">Scheme</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000000</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Count</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3count" class="auto internal xref">Section 7.4.1</a>
</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000001</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Sum</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>
</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000002</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Histogram</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3histogram" class="auto internal xref">Section 7.4.3</a>
</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000003</code> to <code>0x00000FFF</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">reserved for Prio3</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00001000</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Poplar1</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#poplar1-inst" class="auto internal xref">Section 8.4</a>
</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0000</code> to <code>0xFFFFFFFF</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">reserved</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
          </tr>
        </tbody>
      </table>
</div>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-10-3.1">
          <p id="section-10-3.1.1">TODO Add IANA considerations for the codepoints summarized in <a href="#codepoints" class="auto internal xref">Table 16</a>.<a href="#section-10-3.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<section id="section-11">
      <h2 id="name-references">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-11.1">
        <h3 id="name-normative-references">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="FIPS202">[FIPS202]</dt>
        <dd>
<span class="refTitle">"SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions"</span>, <span class="seriesInfo">NIST FIPS PUB 202 </span>, <time datetime="2015-08" class="refDate">August 2015</time>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SP800-185">[SP800-185]</dt>
      <dd>
<span class="refTitle">"SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and ParallelHash"</span>, <span class="seriesInfo">NIST Special Publication 800-185 </span>, <time datetime="2016-12" class="refDate">December 2016</time>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-11.2">
        <h3 id="name-informative-references">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="AGJOP21">[AGJOP21]</dt>
        <dd>
<span class="refAuthor">Addanki, S.</span>, <span class="refAuthor">Garbe, K.</span>, <span class="refAuthor">Jaffe, E.</span>, <span class="refAuthor">Ostrovsky, R.</span>, and <span class="refAuthor">A. Polychroniadou</span>, <span class="refTitle">"Prio+: Privacy Preserving Aggregate Statistics via Boolean Shares"</span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://ia.cr/2021/576">https://ia.cr/2021/576</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI19">[BBCGGI19]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs"</span>, <span class="seriesInfo">CRYPTO 2019 </span>, <time datetime="2019" class="refDate">2019</time>, <span>&lt;<a href="https://ia.cr/2019/188">https://ia.cr/2019/188</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI21">[BBCGGI21]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Lightweight Techniques for Private Heavy Hitters"</span>, <span class="seriesInfo">IEEE S&amp;P 2021 </span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://ia.cr/2021/017">https://ia.cr/2021/017</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CGB17">[CGB17]</dt>
        <dd>
<span class="refAuthor">Corrigan-Gibbs, H.</span> and <span class="refAuthor">D. Boneh</span>, <span class="refTitle">"Prio: Private, Robust, and Scalable Computation of Aggregate Statistics"</span>, <span class="seriesInfo">NSDI 2017 </span>, <time datetime="2017" class="refDate">2017</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.5555/3154630.3154652">https://dl.acm.org/doi/10.5555/3154630.3154652</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DAP">[DAP]</dt>
        <dd>
<span class="refAuthor">Geoghegan, T.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Pitman, B.</span>, <span class="refAuthor">Rescorla, E.</span>, and <span class="refAuthor">C. A. Wood</span>, <span class="refTitle">"Distributed Aggregation Protocol for Privacy Preserving Measurement"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-ppm-dap-10</span>, <time datetime="2024-02-29" class="refDate">29 February 2024</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-10">https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-10</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dou02">[Dou02]</dt>
        <dd>
<span class="refAuthor">Douceur, J.</span>, <span class="refTitle">"The Sybil Attack"</span>, <span class="seriesInfo">IPTPS 2002 </span>, <time datetime="2002" class="refDate">2002</time>, <span>&lt;<a href="https://doi.org/10.1007/3-540-45748-8_24">https://doi.org/10.1007/3-540-45748-8_24</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DPRS23">[DPRS23]</dt>
        <dd>
<span class="refAuthor">Davis, H.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Rosulek, M.</span>, and <span class="refAuthor">P. Schoppmann</span>, <span class="refTitle">"Verifiable Distributed Aggregation Functions"</span>, <span>n.d.</span>, <span>&lt;<a href="https://ia.cr/2023/130">https://ia.cr/2023/130</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dwo06">[Dwo06]</dt>
        <dd>
<span class="refAuthor">Dwork, C.</span>, <span class="refTitle">"Differential Privacy"</span>, <span class="seriesInfo">ICALP 2006 </span>, <time datetime="2006" class="refDate">2006</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/11787006_1">https://link.springer.com/chapter/10.1007/11787006_1</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ENPA">[ENPA]</dt>
        <dd>
<span class="refTitle">"Exposure Notification Privacy-preserving Analytics (ENPA) White Paper"</span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf">https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="EPK14">[EPK14]</dt>
        <dd>
<span class="refAuthor">Erlingsson, Ú.</span>, <span class="refAuthor">Pihur, V.</span>, and <span class="refAuthor">A. Korolova</span>, <span class="refTitle">"RAPPOR: Randomized Aggregatable Privacy-Preserving Ordinal Response"</span>, <span class="seriesInfo">CCS 2014 </span>, <time datetime="2014" class="refDate">2014</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/2660267.2660348">https://dl.acm.org/doi/10.1145/2660267.2660348</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GI14">[GI14]</dt>
        <dd>
<span class="refAuthor">Gilboa, N.</span> and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Distributed Point Functions and Their Applications"</span>, <span class="seriesInfo">EUROCRYPT 2014 </span>, <time datetime="2014" class="refDate">2014</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35">https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GKWWY20">[GKWWY20]</dt>
        <dd>
<span class="refTitle">"Better concrete security for half-gates garbling (in the multi-instance setting)"</span>, <span class="seriesInfo">CRYPTO 2020 </span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-030-56880-1_28">https://link.springer.com/chapter/10.1007/978-3-030-56880-1_28</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OriginTelemetry">[OriginTelemetry]</dt>
      <dd>
<span class="refTitle">"Origin Telemetry"</span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html">https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
<div id="acknowledgments">
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">The security considerations in <a href="#security" class="auto internal xref">Section 9</a> are based largely on the security
analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. Thanks to Hannah Davis and Mike Rosulek, who lent their
time to developing definitions and security proofs.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<p id="appendix-A-2">Thanks to Henry Corrigan-Gibbs, Armando Faz-Hernández, Simon Friedberger, Tim
Geoghegan, Mariana Raykova, Jacob Rothstein, Xiao Wang, and Christopher Wood for
useful feedback on and contributions to the spec.<a href="#appendix-A-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="test-vectors">
<section id="appendix-B">
      <h2 id="name-test-vectors">
<a href="#name-test-vectors" class="section-name selfRef">Test Vectors</a>
      </h2>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-B-1.1">
          <p id="appendix-B-1.1.1">NOTE Machine-readable test vectors can be found at
https://github.com/cfrg/draft-irtf-cfrg-vdaf/tree/main/poc/test_vec.<a href="#appendix-B-1.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="appendix-B-2">Test vectors cover the generation of input shares and the conversion of input
shares into output shares. Vectors specify the verification key, measurements,
aggregation parameter, and any parameters needed to construct the VDAF. (For
example, for <code>Prio3Sum</code>, the user specifies the number of bits for representing
each summand.)<a href="#appendix-B-2" class="pilcrow">¶</a></p>
<p id="appendix-B-3">Byte strings are encoded in hexadecimal. To make the tests deterministic, the
random inputs of randomized algorithms were fixed to the byte sequence starting
with <code>0</code>, incrementing by <code>1</code>, and wrapping at <code>256</code>:<a href="#appendix-B-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-B-4">
<pre>
0, 1, 2, ..., 255, 0, 1, 2, ...
</pre><a href="#appendix-B-4" class="pilcrow">¶</a>
</div>
<div id="testvec-prio3count">
<section id="appendix-B.1">
        <h3 id="name-prio3count-2">
<a href="#name-prio3count-2" class="section-name selfRef">Prio3Count</a>
        </h3>
<div class="alignLeft art-text artwork" id="appendix-B.1-1">
<pre>
verify_key: "000102030405060708090a0b0c0d0e0f"
upload_0:
  measurement: 1
  nonce: "000102030405060708090a0b0c0d0e0f"
  public_share: &gt;-
  input_share_0: &gt;-
    e7a225b76420dd6dd0682380363bd782c8ca9ace6e7abc559dd873bafb503e3cc8b7
    9f3b2b8b0a14676172e46be2ce2f
  input_share_1: &gt;-
    000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
  round_0:
    prep_share_0: &gt;-
      56df20acd68725eab85e44c706629df555d635a5b899df767fe28effd0c45f60
    prep_share_1: &gt;-
      ab20df532878da1518b04178e08a39d0d40fdbfe1876e479dc5e94b43afc68d5
    prep_message: &gt;-
  out_share_0:
    - e7a225b76420dd6d
  out_share_1:
    - 1b5dda489adf2292
agg_share_0: &gt;-
  e7a225b76420dd6d
agg_share_1: &gt;-
  1b5dda489adf2292
agg_result: 1
</pre><a href="#appendix-B.1-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="testvec-prio3sum">
<section id="appendix-B.2">
        <h3 id="name-prio3sum-2">
<a href="#name-prio3sum-2" class="section-name selfRef">Prio3Sum</a>
        </h3>
<div class="alignLeft art-text artwork" id="appendix-B.2-1">
<pre>
bits: 8
verify_key: "000102030405060708090a0b0c0d0e0f"
upload_0:
  measurement: 100
  nonce: "000102030405060708090a0b0c0d0e0f"
  public_share: &gt;-
    da6f5f000d95651e628464f5d086fde6a544464ac776c3812e2299cce1d29095
  input_share_0: &gt;-
    2d97ed6ebc5f6748db3017211c7a31ceeba9500b8317a7f61578b85c08a7f7d95c63
    7bb14b95c062c74bd5b08625bdafbfd91fd01d22291b22b76e54a9be1f7e7015a396
    ae0d6d034b3d22795b3d98db2a9aa51b4ea56c247496d380367deb786a9b34d5cb88
    f0f43e5cb4ab71910c8fa20b0b518f7dd9ce11ec9bf4ce460c81d3e9db05c34e0f05
    14d53f5eadea231dbc1fc575ad52e01622671eaf49a66533a6511710eeea024df0da
    7e7d21451ff5fd9d38e36eee8b78bf7c0767b91e747c6b80d6ca6b726286edebeae4
    ff377040d87f84288f4d0e5960e27b79387caef816c27481be166b71d38d1695e5e5
    061c26f0f667f8fff3133c2ae3ac1853ac542a9af0b5e422764609abd882dedf6aa8
    c835228bbc0cb99a695e81c45a2876a961af0c680662de4400ec96004c45bdc32726
    68b01d7f861f2e03fc18adcc352bdeb7b06b39c2de749da45e9b48f46c45a390cb59
    455dbf3e8be5938203def1c45af5eb5bf2037be005768d74faf11efd255b699f5ae9
    bce8b3bf4688907d11ca89e7609b77c04abde845f63091b934017cf9a83f80eb86fd
    aa063630f86ee982d812062db0d1d760d84cfebbf99927cad516dd028bf2f9e9b7d2
    4aa0bd9c0cb16a46c469eacfe1c48b8d7bf626e5d3eedb3f3cc4972f14a4ba605565
    ec795dd9e68af4ac6185f370f1f77610c64b04d295007b34ed59ed7bceace7b9dea8
    8346a2ee47dfec257ede5cd6985c34abaf5983d067786a695ae1039b631555bbe876
    7baeedfe4f30df6b47479543c58a87e0aaf371234fc9094c4b2b79d025229634a3fd
    f68a36be0e8661a4f043504b7025f03f02e57704b4e410c60e69e88050d0c33ea71b
    c37f306c225f457fbab4929c65ba9401dc57a2dc31bd6d3f53099a00303132333435
    363738393a3b3c3d3e3f
  input_share_1: &gt;-
    000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f2021
    22232425262728292a2b2c2d2e2f
  round_0:
    prep_share_0: &gt;-
      7ae72bff1c063181bfea222dd77bcd40c5d15f62174d4af984d728effb82edd302
      74c927a9ffa51b90c167c60b40c3cdda6f5f000d95651e628464f5d086fde6
    prep_share_1: &gt;-
      8718d400e3f9ce7e2415ddd2288432bf85623812cb8a7cdfed57f5a417c422e25e
      84a67ab22c0b8ef7b0500c366feb95a544464ac776c3812e2299cce1d29095
    prep_message: &gt;-
      4f351791f4d706a31c54ce699ef1af97
  out_share_0:
    - a18d0c7e2a74470727d4f628ff934e52
  out_share_1:
    - c472f381d58bb8f8bc2b09d7006cb1ad
agg_share_0: &gt;-
  a18d0c7e2a74470727d4f628ff934e52
agg_share_1: &gt;-
  c472f381d58bb8f8bc2b09d7006cb1ad
agg_result: 100
</pre><a href="#appendix-B.2-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="testvec-prio3histogram">
<section id="appendix-B.3">
        <h3 id="name-prio3histogram-2">
<a href="#name-prio3histogram-2" class="section-name selfRef">Prio3Histogram</a>
        </h3>
<div class="alignLeft art-text artwork" id="appendix-B.3-1">
<pre>
buckets: [1, 10, 100]
verify_key: "000102030405060708090a0b0c0d0e0f"
upload_0:
  measurement: 50
  nonce: "000102030405060708090a0b0c0d0e0f"
  public_share: &gt;-
    5e015517900cfc204138c24f808ddf4ee85eca87ba246cd715d116195172e500
  input_share_0: &gt;-
    c269f2189db431ca2ebe7230bacd692ac02a7790818681b6ee5ecbd509587b2976c7
    897326840bb70083ee4df8ffe3dc65dbd71f56735a7dcc3a150da8e77171e6d380f2
    f6886845e310dabec4382a037ffc3520737af8874f5b2aec2fae1405cce12c257ef2
    9d22b3e511c30e8f9545251286b3ef3e3728256fc0cc21f5a8ea1d095187cc29132e
    52d24ad778920c740af125833e9a8d2f6b0255740e8d2a4e7b718446610a0650ba40
    61e6a3ee805c1dcffec90d00a3ea5817c9956459538c99efbb56b38eaa6aed93f5a0
    0f11ab0210af030b91c56e6b2b47bb30fcdc5f44a28b5d733e4661cbd736ae071e78
    4f99ba86ff2688f6751d2d16e80ddd99c9aceeb39ca660215f0fc1178f828e295840
    f941fa9a3217afd52b32ec6c8ee3ec58291f2c88e8150374ccfd503f07bc0021d6a9
    f1c81050df96ec5ce5c7d4f41255303132333435363738393a3b3c3d3e3f
  input_share_1: &gt;-
    000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f2021
    22232425262728292a2b2c2d2e2f
  round_0:
    prep_share_0: &gt;-
      ac872edaaaa532de61bcd63b168e522230b35064b09b6b35c1352bc354560fdeac
      684da645d3e509c6db8ba31f58dabb5e015517900cfc204138c24f808ddf4e
    prep_share_1: &gt;-
      5578d125555acd21824329c4e971adddc07187f0f25a30ceba8407513f60f8e3d1
      5c17270c5631a718b3b4f5702aff54e85eca87ba246cd715d116195172e500
    prep_message: &gt;-
      890bfbdf0c619d5c853a92e28bce41b3
  out_share_0:
    - c269f2189db431ca2ebe7230bacd692a
    - c02a7790818681b6ee5ecbd509587b29
    - 76c7897326840bb70083ee4df8ffe3dc
    - 65dbd71f56735a7dcc3a150da8e77171
  out_share_1:
    - 3f960de7624bce35b5418dcf453296d5
    - 41d5886f7e797e49f5a0342af6a784d6
    - 8c38768cd97bf448e37c11b207001c23
    - 9c2428e0a98ca58217c5eaf257188e8e
agg_share_0: &gt;-
  c269f2189db431ca2ebe7230bacd692ac02a7790818681b6ee5ecbd509587b2976c789
  7326840bb70083ee4df8ffe3dc65dbd71f56735a7dcc3a150da8e77171
agg_share_1: &gt;-
  3f960de7624bce35b5418dcf453296d541d5886f7e797e49f5a0342af6a784d68c3876
  8cd97bf448e37c11b207001c239c2428e0a98ca58217c5eaf257188e8e
agg_result: [0, 0, 1, 0]
</pre><a href="#appendix-B.3-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="testvec-poplar1">
<section id="appendix-B.4">
        <h3 id="name-poplar1-2">
<a href="#name-poplar1-2" class="section-name selfRef">Poplar1</a>
        </h3>
<div id="sharding-1">
<section id="appendix-B.4.1">
          <h4 id="name-sharding-4">
<a href="#name-sharding-4" class="section-name selfRef">Sharding</a>
          </h4>
<div class="alignLeft art-text artwork" id="appendix-B.4.1-1">
<pre>
bits: 4
upload_0:
  measurement: 13
  nonce: "000102030405060708090a0b0c0d0e0f"
  public_share: &gt;-
    8b332c8b09b84f5801ad1cfd30b0df3fba69d11ddf6065a9cdb87cb31579ba0443a4
    82f4ed21ac079b96f5944d1669a1159406148c00878ac9953bcfbadc0273042653fd
    0fae8c43ce746fd31f248d1cbf5d1bc01fe02a883571cf38a1a4c10f54d41979b6fc
    35ef1fb051f968ba4397b8e61a81d835fa7ee54b949a35abf76c13e0a9daf90f1528
    c40db5904b6e24d70116538b28c16d9dbfee45000fe14db45cafbb76768b28250e74
    6af691f4bb1619
  input_share_0: &gt;-
    000102030405060708090a0b0c0d0e0f202122232425262728292a2b2c2d2e2f0734
    d55dcb0dec9599b96f38ca694d46056dbe5bb24ab41ca10faaa8249839632c6503c9
    795300a160e8c378762f3b329e9ebe6a081eaed2d72aaff0aeb52415211c314f609a
    0377e66b7be10a3d8d4e75890da4c93f62172bc07e54be31c060c5970b52af8e8633
    d63560f59fa0bb36
  input_share_1: &gt;-
    101112131415161718191a1b1c1d1e1f303132333435363738393a3b3c3d3e3f9558
    af2229b50110d88e17b5b3a81902194a5eab5f8ad69f5c061f16ac1e92deadc3c6ed
    32714a3756fa68e580d523d6c0e4b92ba2277033a7adb060e7a2ee3b2e44591d7c99
    b1cbcbfc58e4ae9ef7613a1ff24e53201e7264940bed2cd318e8e80ab7aae630f342
    911d75c85980691d
</pre><a href="#appendix-B.4.1-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="preparation-aggregation-and-unsharding">
<section id="appendix-B.4.2">
          <h4 id="name-preparation-aggregation-and">
<a href="#name-preparation-aggregation-and" class="section-name selfRef">Preparation, Aggregation, and Unsharding</a>
          </h4>
<div class="alignLeft art-text artwork" id="appendix-B.4.2-1">
<pre>
verify_key: "000102030405060708090a0b0c0d0e0f"
agg_param: (0, [0, 1])
upload_0:
  round_0:
    prep_share_0: &gt;-
      a2d369b7ee44e5f8b903e889b37ea7ef4d29ee36d1abdb13
    prep_share_1: &gt;-
      31182ff6e075b925a06c802eac3b14c1ad66ce991ca2ffc2
    prep_message: &gt;-
      d2eb98add0ba9e1e587068b860babbb0fa8fbcd0ed4ddbd6
  round_1:
    prep_share_0: &gt;-
      f4445265dc801ab5
    prep_share_1: &gt;-
      0dbbad9a227fe54a
    prep_message: &gt;-
  out_share_0:
    - d47170d4f804449e
    - e16add75c1d3f0c4
  out_share_1:
    - 2d8e8f2b06fbbb61
    - 2195228a3d2c0f3b
agg_share_0: &gt;-
  d47170d4f804449ee16add75c1d3f0c4
agg_share_1: &gt;-
  2d8e8f2b06fbbb612195228a3d2c0f3b
agg_result: [0, 1]
</pre><a href="#appendix-B.4.2-1" class="pilcrow">¶</a>
</div>
<div class="alignLeft art-text artwork" id="appendix-B.4.2-2">
<pre>
verify_key: "000102030405060708090a0b0c0d0e0f"
agg_param: (1, [0, 1, 2, 3])
upload_0:
  round_0:
    prep_share_0: &gt;-
      94352b588fbd978be7ef2cacb83b1b64c1d11af699253242
    prep_share_1: &gt;-
      4a3529a2b34159be1666064ba0a3a9cc4e72223ef6d0ac79
    prep_message: &gt;-
      dd6a54fa43fff049fc5533f759dfc4300f443d3490f6debb
  round_1:
    prep_share_0: &gt;-
      3dc2833b1f9010ee
    prep_share_1: &gt;-
      c43d7cc4df6fef11
    prep_message: &gt;-
  out_share_0:
    - c03ede9261e7f441
    - 8ef9fde3f50eb967
    - de3bb4acf0b9dff8
    - 24687334644cc809
  out_share_1:
    - 41c1216d9d180bbe
    - 7306021c09f14698
    - 23c44b530e462007
    - de978ccb9ab337f6
agg_share_0: &gt;-
  c03ede9261e7f4418ef9fde3f50eb967de3bb4acf0b9dff824687334644cc809
agg_share_1: &gt;-
  41c1216d9d180bbe7306021c09f1469823c44b530e462007de978ccb9ab337f6
agg_result: [0, 0, 0, 1]
</pre><a href="#appendix-B.4.2-2" class="pilcrow">¶</a>
</div>
<div class="alignLeft art-text artwork" id="appendix-B.4.2-3">
<pre>
verify_key: "000102030405060708090a0b0c0d0e0f"
agg_param: (2, [0, 2, 4, 6])
upload_0:
  round_0:
    prep_share_0: &gt;-
      b640798e11bc37ac1f4981c99f0de15569b2bcc187d2f0f2
    prep_share_1: &gt;-
      37a720e1739caca1b39b8fe97ce96e09277eee9cc694c2cf
    prep_message: &gt;-
      ece7996f8658e44dd2e410b31cf74f5f8f30ab5e4f67b3c2
  round_1:
    prep_share_0: &gt;-
      52a1848f964385f8
    prep_share_1: &gt;-
      af5e7b7068bc7a07
    prep_message: &gt;-
  out_share_0:
    - 352395a6c5e5804e
    - f9b61274892e76dd
    - b27e3eb4accbaa0a
    - 3b1c4a7f78d59935
  out_share_1:
    - ccdc6a59391a7fb1
    - 0849ed8b75d18922
    - 4f81c14b523455f5
    - c7e3b580862a66ca
agg_share_0: &gt;-
  352395a6c5e5804ef9b61274892e76ddb27e3eb4accbaa0a3b1c4a7f78d59935
agg_share_1: &gt;-
  ccdc6a59391a7fb10849ed8b75d189224f81c14b523455f5c7e3b580862a66ca
agg_result: [0, 0, 0, 1]
</pre><a href="#appendix-B.4.2-3" class="pilcrow">¶</a>
</div>
<div class="alignLeft art-text artwork" id="appendix-B.4.2-4">
<pre>
verify_key: "000102030405060708090a0b0c0d0e0f"
agg_param: (3, [1, 3, 5, 7, 9, 13, 15])
upload_0:
  round_0:
    prep_share_0: &gt;-
      08efd12285f6e61599b2f9d941577fd843597d3b15f747d15b0b02daf6147752c6
      a7a72723fa0cad98c7c38a0716ff8833dd7f97d40ed374f963dd2bced921614ccd
      4dca993e6c4f5d1ab0ce9bf37df76b41e2c111868322dfc39b3145dfc832
    prep_share_1: &gt;-
      04eb21e562d79e4255b2c5001ed5949fc01841f40d921fdf5c1100b5c993f34e9d
      a143558cc507fb9c3e3832d85b751575b8f5a102257b141b94027bc0a849013f46
      00d8257361b9d17e43f8cddc106b512f69c78b63bcde177e2d3c0cfb353d
    prep_message: &gt;-
      1fdaf307e8cd8558ee64bfda5f2c14780472be2f238967b0b81c028fc0a86a2163
      49eb7cafbf14a83506fcbcdf71749ea8957539d7334e8914f8dfa68e826b628b13
      4ea2bfb1cd082f99f3c669d08e62bd704b899de93f01f741c96d51dafe6f
  round_1:
    prep_share_0: &gt;-
      3e1ded312b78a4a2003d9365472d481c0adb6411d7049869693fb0b331750301
    prep_share_1: &gt;-
      afe212ced4875b5dffc26c9ab8d2b7e3f5249bee28fb679696c04f4cce8afc7e
    prep_message: &gt;-
  out_share_0:
    - 034a3226150cf3aa5e7f6e76b0c6a6b2aa9b750cdafdc6aae0ff2f4076894e2a
    - 1413b483f800a4faa67b1e1c6bb1be2a1c9cc590761edb85f77692b67f9c696a
    - 85591b91ee55008c7e7a58176d5bce3ca9974482b0c1aa2b7c69e0ab2e2e212c
    - 03d9e6cde627cc30ceac7a6b5e3192a382d641e761c05c01eea4bc543c7fc41d
    - cd8891db6ac77a7fbba2c401c1488b8d31ee2cbc65cb26d02cb037cc99d32543
    - 732e3e133c6d8c9a0f6647fc24be3c5d8a960b63c3163979fd4d42fd554a7812
    - 8a2964a89cd70d7ba65bb52f0f15fb2db7dc1c534d743e37f223f74b8489c85d
  out_share_1:
    - eab5cdd9eaf30c55a18091894f39594d55648af3250239551f00d0bf8976b155
    - d9ec4b7c07ff5b055984e1e3944e41d5e3633a6f89e1247a08896d4980639615
    - 68a6e46e11aaff738185a7e892a431c35668bb7d4f3e55d483961f54d1d1de53
    - ea26193219d833cf31538594a1ce6d5c7d29be189e3fa3fe115b43abc3803b62
    - 20776e2495388580445d3bfe3eb77472ce11d3439a34d92fd34fc833662cda3c
    - 7bd1c1ecc3927365f099b803db41c3a27569f49c3ce9c68602b2bd02aab5876d
    - 63d69b576328f28459a44ad0f0ea04d24823e3acb28bc1c80ddc08b47b763722
agg_share_0: &gt;-
  034a3226150cf3aa5e7f6e76b0c6a6b2aa9b750cdafdc6aae0ff2f4076894e2a1413b4
  83f800a4faa67b1e1c6bb1be2a1c9cc590761edb85f77692b67f9c696a85591b91ee55
  008c7e7a58176d5bce3ca9974482b0c1aa2b7c69e0ab2e2e212c03d9e6cde627cc30ce
  ac7a6b5e3192a382d641e761c05c01eea4bc543c7fc41dcd8891db6ac77a7fbba2c401
  c1488b8d31ee2cbc65cb26d02cb037cc99d32543732e3e133c6d8c9a0f6647fc24be3c
  5d8a960b63c3163979fd4d42fd554a78128a2964a89cd70d7ba65bb52f0f15fb2db7dc
  1c534d743e37f223f74b8489c85d
agg_share_1: &gt;-
  eab5cdd9eaf30c55a18091894f39594d55648af3250239551f00d0bf8976b155d9ec4b
  7c07ff5b055984e1e3944e41d5e3633a6f89e1247a08896d498063961568a6e46e11aa
  ff738185a7e892a431c35668bb7d4f3e55d483961f54d1d1de53ea26193219d833cf31
  538594a1ce6d5c7d29be189e3fa3fe115b43abc3803b6220776e2495388580445d3bfe
  3eb77472ce11d3439a34d92fd34fc833662cda3c7bd1c1ecc3927365f099b803db41c3
  a27569f49c3ce9c68602b2bd02aab5876d63d69b576328f28459a44ad0f0ea04d24823
  e3acb28bc1c80ddc08b47b763722
agg_result: [0, 0, 0, 0, 0, 1, 0]
</pre><a href="#appendix-B.4.2-4" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-C">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Richard L. Barnes</span></div>
<div dir="auto" class="left"><span class="org">Cisco</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:rlb@ipv.sx" class="email">rlb@ipv.sx</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Cook</span></div>
<div dir="auto" class="left"><span class="org">ISRG</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:divergentdave@gmail.com" class="email">divergentdave@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Christopher Patton</span></div>
<div dir="auto" class="left"><span class="org">Cloudflare</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:chrispatton+ietf@gmail.com" class="email">chrispatton+ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Phillipp Schoppmann</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:schoppmann@google.com" class="email">schoppmann@google.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
